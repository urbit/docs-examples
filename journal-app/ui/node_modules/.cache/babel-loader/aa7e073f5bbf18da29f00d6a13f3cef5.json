{"ast":null,"code":"class ResumableError extends Error {}\n\nclass FatalError extends Error {}\n\nvar lib = {};\nObject.defineProperty(lib, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n/* global window self */\n\n\nvar isBrowser = typeof window !== 'undefined' && typeof window.document !== 'undefined';\n/* eslint-disable no-restricted-globals */\n\nvar isWebWorker = (typeof self === 'undefined' ? 'undefined' : _typeof(self)) === 'object' && self.constructor && self.constructor.name === 'DedicatedWorkerGlobalScope';\n/* eslint-enable no-restricted-globals */\n\nvar isNode = typeof process !== 'undefined' && process.versions != null && process.versions.node != null;\n/**\n * @see https://github.com/jsdom/jsdom/releases/tag/12.0.0\n * @see https://github.com/jsdom/jsdom/issues/1537\n */\n\n/* eslint-disable no-undef */\n\nvar isJsDom = function isJsDom() {\n  return typeof window !== 'undefined' && window.name === 'nodejs' || navigator.userAgent.includes('Node.js') || navigator.userAgent.includes('jsdom');\n};\n\nvar isBrowser_1 = lib.isBrowser = isBrowser;\nlib.isWebWorker = isWebWorker;\nlib.isNode = isNode;\nlib.isJsDom = isJsDom;\n\nasync function getBytes(stream, onChunk) {\n  const reader = stream.getReader();\n  let result;\n\n  while (!(result = await reader.read()).done) {\n    onChunk(result.value);\n  }\n}\n\nfunction getLines(onLine) {\n  let buffer;\n  let position;\n  let fieldLength;\n  let discardTrailingNewline = false;\n  return function onChunk(arr) {\n    if (buffer === undefined) {\n      buffer = arr;\n      position = 0;\n      fieldLength = -1;\n    } else {\n      buffer = concat(buffer, arr);\n    }\n\n    const bufLength = buffer.length;\n    let lineStart = 0;\n\n    while (position < bufLength) {\n      if (discardTrailingNewline) {\n        if (buffer[position] === 10) {\n          lineStart = ++position;\n        }\n\n        discardTrailingNewline = false;\n      }\n\n      let lineEnd = -1;\n\n      for (; position < bufLength && lineEnd === -1; ++position) {\n        switch (buffer[position]) {\n          case 58:\n            if (fieldLength === -1) {\n              fieldLength = position - lineStart;\n            }\n\n            break;\n\n          case 13:\n            discardTrailingNewline = true;\n\n          case 10:\n            lineEnd = position;\n            break;\n        }\n      }\n\n      if (lineEnd === -1) {\n        break;\n      }\n\n      onLine(buffer.subarray(lineStart, lineEnd), fieldLength);\n      lineStart = position;\n      fieldLength = -1;\n    }\n\n    if (lineStart === bufLength) {\n      buffer = undefined;\n    } else if (lineStart !== 0) {\n      buffer = buffer.subarray(lineStart);\n      position -= lineStart;\n    }\n  };\n}\n\nfunction getMessages(onId, onRetry, onMessage) {\n  let message = newMessage();\n  const decoder = new TextDecoder();\n  return function onLine(line, fieldLength) {\n    if (line.length === 0) {\n      onMessage === null || onMessage === void 0 ? void 0 : onMessage(message);\n      message = newMessage();\n    } else if (fieldLength > 0) {\n      const field = decoder.decode(line.subarray(0, fieldLength));\n      const valueOffset = fieldLength + (line[fieldLength + 1] === 32 ? 2 : 1);\n      const value = decoder.decode(line.subarray(valueOffset));\n\n      switch (field) {\n        case 'data':\n          message.data = message.data ? message.data + '\\n' + value : value;\n          break;\n\n        case 'event':\n          message.event = value;\n          break;\n\n        case 'id':\n          onId(message.id = value);\n          break;\n\n        case 'retry':\n          const retry = parseInt(value, 10);\n\n          if (!isNaN(retry)) {\n            onRetry(message.retry = retry);\n          }\n\n          break;\n      }\n    }\n  };\n}\n\nfunction concat(a, b) {\n  const res = new Uint8Array(a.length + b.length);\n  res.set(a);\n  res.set(b, a.length);\n  return res;\n}\n\nfunction newMessage() {\n  return {\n    data: '',\n    event: '',\n    id: '',\n    retry: undefined\n  };\n}\n\nvar __rest = undefined && undefined.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nconst EventStreamContentType = 'text/event-stream';\nconst DefaultRetryInterval = 1000;\nconst LastEventId = 'last-event-id';\n\nfunction fetchEventSource(input, _a) {\n  var {\n    signal: inputSignal,\n    headers: inputHeaders,\n    onopen: inputOnOpen,\n    onmessage,\n    onclose,\n    onerror,\n    openWhenHidden,\n    fetch: inputFetch\n  } = _a,\n      rest = __rest(_a, [\"signal\", \"headers\", \"onopen\", \"onmessage\", \"onclose\", \"onerror\", \"openWhenHidden\", \"fetch\"]);\n\n  return new Promise((resolve, reject) => {\n    const headers = Object.assign({}, inputHeaders);\n\n    if (!headers.accept) {\n      headers.accept = EventStreamContentType;\n    }\n\n    let curRequestController;\n\n    function onVisibilityChange() {\n      curRequestController.abort();\n\n      if (!document.hidden) {\n        create();\n      }\n    }\n\n    if (!openWhenHidden) {\n      document.addEventListener('visibilitychange', onVisibilityChange);\n    }\n\n    let retryInterval = DefaultRetryInterval;\n    let retryTimer = 0;\n\n    function dispose() {\n      document.removeEventListener('visibilitychange', onVisibilityChange);\n      window.clearTimeout(retryTimer);\n      curRequestController.abort();\n    }\n\n    inputSignal === null || inputSignal === void 0 ? void 0 : inputSignal.addEventListener('abort', () => {\n      dispose();\n      resolve();\n    });\n    const fetch = inputFetch !== null && inputFetch !== void 0 ? inputFetch : window.fetch;\n    const onopen = inputOnOpen !== null && inputOnOpen !== void 0 ? inputOnOpen : defaultOnOpen;\n\n    async function create() {\n      var _a;\n\n      curRequestController = new AbortController();\n\n      try {\n        const response = await fetch(input, Object.assign(Object.assign({}, rest), {\n          headers,\n          signal: curRequestController.signal\n        }));\n        await onopen(response);\n        await getBytes(response.body, getLines(getMessages(id => {\n          if (id) {\n            headers[LastEventId] = id;\n          } else {\n            delete headers[LastEventId];\n          }\n        }, retry => {\n          retryInterval = retry;\n        }, onmessage)));\n        onclose === null || onclose === void 0 ? void 0 : onclose();\n        dispose();\n        resolve();\n      } catch (err) {\n        if (!curRequestController.signal.aborted) {\n          try {\n            const interval = (_a = onerror === null || onerror === void 0 ? void 0 : onerror(err)) !== null && _a !== void 0 ? _a : retryInterval;\n            window.clearTimeout(retryTimer);\n            retryTimer = window.setTimeout(create, interval);\n          } catch (innerErr) {\n            dispose();\n            reject(innerErr);\n          }\n        }\n      }\n    }\n\n    create();\n  });\n}\n\nfunction defaultOnOpen(response) {\n  const contentType = response.headers.get('content-type');\n\n  if (!(contentType === null || contentType === void 0 ? void 0 : contentType.startsWith(EventStreamContentType))) {\n    throw new Error(`Expected content-type to be ${EventStreamContentType}, Actual: ${contentType}`);\n  }\n}\n/**\r\n * Returns a hex string of given length.\r\n *\r\n * Poached from StackOverflow.\r\n *\r\n * @param len Length of hex string to return.\r\n */\n\n\nfunction hexString(len) {\n  const maxlen = 8;\n  const min = Math.pow(16, Math.min(len, maxlen) - 1);\n  const max = Math.pow(16, Math.min(len, maxlen)) - 1;\n  const n = Math.floor(Math.random() * (max - min + 1)) + min;\n  let r = n.toString(16);\n\n  while (r.length < len) {\n    r = r + hexString(len - maxlen);\n  }\n\n  return r;\n}\n/**\r\n * A class for interacting with an urbit ship, given its URL and code\r\n */\n\n\nclass Urbit {\n  /**\r\n   * Constructs a new Urbit connection.\r\n   *\r\n   * @param url  The URL (with protocol and port) of the ship to be accessed. If\r\n   * the airlock is running in a webpage served by the ship, this should just\r\n   * be the empty string.\r\n   * @param code The access code for the ship at that address\r\n   */\n  constructor(url, code, desk) {\n    this.url = url;\n    this.code = code;\n    this.desk = desk;\n    /**\r\n     * UID will be used for the channel: The current unix time plus a random hex string\r\n     */\n\n    this.uid = `${Math.floor(Date.now() / 1000)}-${hexString(6)}`;\n    /**\r\n     * Last Event ID is an auto-updated index of which events have been sent over this channel\r\n     */\n\n    this.lastEventId = 0;\n    this.lastAcknowledgedEventId = 0;\n    /**\r\n     * SSE Client is null for now; we don't want to start polling until it the channel exists\r\n     */\n\n    this.sseClientInitialized = false;\n    /**\r\n     * A registry of requestId to successFunc/failureFunc\r\n     *\r\n     * These functions are registered during a +poke and are executed\r\n     * in the onServerEvent()/onServerError() callbacks. Only one of\r\n     * the functions will be called, and the outstanding poke will be\r\n     * removed after calling the success or failure function.\r\n     */\n\n    this.outstandingPokes = new Map();\n    /**\r\n     * A registry of requestId to subscription functions.\r\n     *\r\n     * These functions are registered during a +subscribe and are\r\n     * executed in the onServerEvent()/onServerError() callbacks. The\r\n     * event function will be called whenever a new piece of data on this\r\n     * subscription is available, which may be 0, 1, or many times. The\r\n     * disconnect function may be called exactly once.\r\n     */\n\n    this.outstandingSubscriptions = new Map();\n    /**\r\n     * Our abort controller, used to close the connection\r\n     */\n\n    this.abort = new AbortController();\n    /**\r\n     * number of consecutive errors in connecting to the eventsource\r\n     */\n\n    this.errorCount = 0;\n    this.onError = null;\n    this.onRetry = null;\n    this.onOpen = null;\n\n    if (isBrowser_1) {\n      window.addEventListener('beforeunload', this.delete);\n    }\n\n    return this;\n  }\n  /** This is basic interpolation to get the channel URL of an instantiated Urbit connection. */\n\n\n  get channelUrl() {\n    return `${this.url}/~/channel/${this.uid}`;\n  }\n\n  get fetchOptions() {\n    const headers = {\n      'Content-Type': 'application/json'\n    };\n\n    if (!isBrowser_1) {\n      headers.Cookie = this.cookie;\n    }\n\n    return {\n      credentials: 'include',\n      accept: '*',\n      headers,\n      signal: this.abort.signal\n    };\n  }\n  /**\r\n   * All-in-one hook-me-up.\r\n   *\r\n   * Given a ship, url, and code, this returns an airlock connection\r\n   * that is ready to go. It `|hi`s itself to create the channel,\r\n   * then opens the channel via EventSource.\r\n   *\r\n   */\n\n\n  static async authenticate(_ref) {\n    let {\n      ship,\n      url,\n      code,\n      verbose = false\n    } = _ref;\n    const airlock = new Urbit(`http://${url}`, code);\n    airlock.verbose = verbose;\n    airlock.ship = ship;\n    await airlock.connect();\n    await airlock.poke({\n      app: 'hood',\n      mark: 'helm-hi',\n      json: 'opening airlock'\n    });\n    await airlock.eventSource();\n    return airlock;\n  }\n  /**\r\n   * Connects to the Urbit ship. Nothing can be done until this is called.\r\n   * That's why we roll it into this.authenticate\r\n   */\n\n\n  async connect() {\n    if (this.verbose) {\n      console.log(`password=${this.code} `, isBrowser_1 ? 'Connecting in browser context at ' + `${this.url}/~/login` : 'Connecting from node context');\n    }\n\n    return fetch(`${this.url}/~/login`, {\n      method: 'post',\n      body: `password=${this.code}`,\n      credentials: 'include'\n    }).then(response => {\n      if (this.verbose) {\n        console.log('Received authentication response', response);\n      }\n\n      const cookie = response.headers.get('set-cookie');\n\n      if (!this.ship) {\n        this.ship = new RegExp(/urbauth-~([\\w-]+)/).exec(cookie)[1];\n      }\n\n      if (!isBrowser_1) {\n        this.cookie = cookie;\n      }\n    });\n  }\n  /**\r\n   * Initializes the SSE pipe for the appropriate channel.\r\n   */\n\n\n  async eventSource() {\n    if (this.sseClientInitialized) {\n      return Promise.resolve();\n    }\n\n    if (this.lastEventId === 0) {\n      // Can't receive events until the channel is open,\n      // so poke and open then\n      await this.poke({\n        app: 'hood',\n        mark: 'helm-hi',\n        json: 'Opening API channel'\n      });\n      return;\n    }\n\n    this.sseClientInitialized = true;\n    return new Promise((resolve, reject) => {\n      fetchEventSource(this.channelUrl, { ...this.fetchOptions,\n        openWhenHidden: true,\n        onopen: async response => {\n          if (this.verbose) {\n            console.log('Opened eventsource', response);\n          }\n\n          if (response.ok) {\n            this.errorCount = 0;\n            this.onOpen && this.onOpen();\n            resolve();\n            return; // everything's good\n          } else {\n            const err = new Error('failed to open eventsource');\n            reject(err);\n          }\n        },\n        onmessage: event => {\n          if (this.verbose) {\n            console.log('Received SSE: ', event);\n          }\n\n          if (!event.id) return;\n          this.lastEventId = parseInt(event.id, 10);\n\n          if (this.lastEventId - this.lastAcknowledgedEventId > 20) {\n            this.ack(this.lastEventId);\n          }\n\n          if (event.data && JSON.parse(event.data)) {\n            const data = JSON.parse(event.data);\n\n            if (data.response === 'poke' && this.outstandingPokes.has(data.id)) {\n              const funcs = this.outstandingPokes.get(data.id);\n\n              if (data.hasOwnProperty('ok')) {\n                funcs.onSuccess();\n              } else if (data.hasOwnProperty('err')) {\n                console.error(data.err);\n                funcs.onError(data.err);\n              } else {\n                console.error('Invalid poke response', data);\n              }\n\n              this.outstandingPokes.delete(data.id);\n            } else if (data.response === 'subscribe' && this.outstandingSubscriptions.has(data.id)) {\n              const funcs = this.outstandingSubscriptions.get(data.id);\n\n              if (data.hasOwnProperty('err')) {\n                console.error(data.err);\n                funcs.err(data.err, data.id);\n                this.outstandingSubscriptions.delete(data.id);\n              }\n            } else if (data.response === 'diff' && this.outstandingSubscriptions.has(data.id)) {\n              const funcs = this.outstandingSubscriptions.get(data.id);\n\n              try {\n                funcs.event(data.json);\n              } catch (e) {\n                console.error('Failed to call subscription event callback', e);\n              }\n            } else if (data.response === 'quit' && this.outstandingSubscriptions.has(data.id)) {\n              const funcs = this.outstandingSubscriptions.get(data.id);\n              funcs.quit(data);\n              this.outstandingSubscriptions.delete(data.id);\n            } else {\n              console.log([...this.outstandingSubscriptions.keys()]);\n              console.log('Unrecognized response', data);\n            }\n          }\n        },\n        onerror: error => {\n          console.warn(error);\n\n          if (this.errorCount++ < 4) {\n            this.onRetry && this.onRetry();\n            return Math.pow(2, this.errorCount - 1) * 750;\n          }\n\n          this.onError && this.onError(error);\n          throw error;\n        },\n        onclose: () => {\n          console.log('e');\n          throw new Error('Ship unexpectedly closed the connection');\n        }\n      });\n    });\n  }\n  /**\r\n   * Reset airlock, abandoning current subscriptions and wiping state\r\n   *\r\n   */\n\n\n  reset() {\n    this.delete();\n    this.abort.abort();\n    this.abort = new AbortController();\n    this.uid = `${Math.floor(Date.now() / 1000)}-${hexString(6)}`;\n    this.lastEventId = 0;\n    this.lastAcknowledgedEventId = 0;\n    this.outstandingSubscriptions = new Map();\n    this.outstandingPokes = new Map();\n    this.sseClientInitialized = false;\n  }\n  /**\r\n   * Autoincrements the next event ID for the appropriate channel.\r\n   */\n\n\n  getEventId() {\n    this.lastEventId = Number(this.lastEventId) + 1;\n    return this.lastEventId;\n  }\n  /**\r\n   * Acknowledges an event.\r\n   *\r\n   * @param eventId The event to acknowledge.\r\n   */\n\n\n  async ack(eventId) {\n    this.lastAcknowledgedEventId = eventId;\n    const message = {\n      action: 'ack',\n      'event-id': eventId\n    };\n    await this.sendJSONtoChannel(message);\n    return eventId;\n  }\n\n  async sendJSONtoChannel() {\n    for (var _len = arguments.length, json = new Array(_len), _key = 0; _key < _len; _key++) {\n      json[_key] = arguments[_key];\n    }\n\n    const response = await fetch(this.channelUrl, { ...this.fetchOptions,\n      method: 'PUT',\n      body: JSON.stringify(json)\n    });\n\n    if (!response.ok) {\n      throw new Error('Failed to PUT channel');\n    }\n\n    if (!this.sseClientInitialized) {\n      await this.eventSource();\n    }\n  }\n  /**\r\n   * Creates a subscription, waits for a fact and then unsubscribes\r\n   *\r\n   * @param app Name of gall agent to subscribe to\r\n   * @param path Path to subscribe to\r\n   * @param timeout Optional timeout before ending subscription\r\n   *\r\n   * @returns The first fact on the subcription\r\n   */\n\n\n  async subscribeOnce(app, path, timeout) {\n    return new Promise(async (resolve, reject) => {\n      let done = false;\n      let id = null;\n\n      const quit = () => {\n        if (!done) {\n          reject('quit');\n        }\n      };\n\n      const event = e => {\n        if (!done) {\n          resolve(e);\n          this.unsubscribe(id);\n        }\n      };\n\n      const request = {\n        app,\n        path,\n        event,\n        err: reject,\n        quit\n      };\n      id = await this.subscribe(request);\n\n      if (timeout) {\n        setTimeout(() => {\n          if (!done) {\n            done = true;\n            reject('timeout');\n            this.unsubscribe(id);\n          }\n        }, timeout);\n      }\n    });\n  }\n  /**\r\n   * Pokes a ship with data.\r\n   *\r\n   * @param app The app to poke\r\n   * @param mark The mark of the data being sent\r\n   * @param json The data to send\r\n   */\n\n\n  async poke(params) {\n    const {\n      app,\n      mark,\n      json,\n      ship,\n      onSuccess,\n      onError\n    } = {\n      onSuccess: () => {},\n      onError: () => {},\n      ship: this.ship,\n      ...params\n    };\n    const message = {\n      id: this.getEventId(),\n      action: 'poke',\n      ship,\n      app,\n      mark,\n      json\n    };\n    const [send, result] = await Promise.all([this.sendJSONtoChannel(message), new Promise((resolve, reject) => {\n      this.outstandingPokes.set(message.id, {\n        onSuccess: () => {\n          onSuccess();\n          resolve(message.id);\n        },\n        onError: event => {\n          onError(event);\n          reject(event.err);\n        }\n      });\n    })]);\n    return result;\n  }\n  /**\r\n   * Subscribes to a path on an app on a ship.\r\n   *\r\n   *\r\n   * @param app The app to subsribe to\r\n   * @param path The path to which to subscribe\r\n   * @param handlers Handlers to deal with various events of the subscription\r\n   */\n\n\n  async subscribe(params) {\n    const {\n      app,\n      path,\n      ship,\n      err,\n      event,\n      quit\n    } = {\n      err: () => {},\n      event: () => {},\n      quit: () => {},\n      ship: this.ship,\n      ...params\n    };\n    const message = {\n      id: this.getEventId(),\n      action: 'subscribe',\n      ship,\n      app,\n      path\n    };\n    this.outstandingSubscriptions.set(message.id, {\n      app,\n      path,\n      err,\n      event,\n      quit\n    });\n    await this.sendJSONtoChannel(message);\n    return message.id;\n  }\n  /**\r\n   * Unsubscribes to a given subscription.\r\n   *\r\n   * @param subscription\r\n   */\n\n\n  async unsubscribe(subscription) {\n    return this.sendJSONtoChannel({\n      id: this.getEventId(),\n      action: 'unsubscribe',\n      subscription\n    }).then(() => {\n      this.outstandingSubscriptions.delete(subscription);\n    });\n  }\n  /**\r\n   * Deletes the connection to a channel.\r\n   */\n\n\n  delete() {\n    if (isBrowser_1) {\n      navigator.sendBeacon(this.channelUrl, JSON.stringify([{\n        action: 'delete'\n      }]));\n    }\n  }\n  /**\r\n   * Scry into an gall agent at a path\r\n   *\r\n   * @typeParam T - Type of the scry result\r\n   *\r\n   * @remarks\r\n   *\r\n   * Equivalent to\r\n   * ```hoon\r\n   * .^(T %gx /(scot %p our)/[app]/(scot %da now)/[path]/json)\r\n   * ```\r\n   * The returned cage must have a conversion to JSON for the scry to succeed\r\n   *\r\n   * @param params The scry request\r\n   * @returns The scry result\r\n   */\n\n\n  async scry(params) {\n    const {\n      app,\n      path\n    } = params;\n    const response = await fetch(`${this.url}/~/scry/${app}${path}.json`, this.fetchOptions);\n    return await response.json();\n  }\n  /**\r\n   * Run a thread\r\n   *\r\n   *\r\n   * @param inputMark   The mark of the data being sent\r\n   * @param outputMark  The mark of the data being returned\r\n   * @param threadName  The thread to run\r\n   * @param body        The data to send to the thread\r\n   * @returns  The return value of the thread\r\n   */\n\n\n  async thread(params) {\n    const {\n      inputMark,\n      outputMark,\n      threadName,\n      body,\n      desk = this.desk\n    } = params;\n\n    if (!desk) {\n      throw new Error('Must supply desk to run thread from');\n    }\n\n    const res = await fetch(`${this.url}/spider/${desk}/${inputMark}/${threadName}/${outputMark}.json`, { ...this.fetchOptions,\n      method: 'POST',\n      body: JSON.stringify(body)\n    });\n    return res.json();\n  }\n  /**\r\n   * Utility function to connect to a ship that has its *.arvo.network domain configured.\r\n   *\r\n   * @param name Name of the ship e.g. zod\r\n   * @param code Code to log in\r\n   */\n\n\n  static async onArvoNetwork(ship, code) {\n    const url = `https://${ship}.arvo.network`;\n    return await Urbit.authenticate({\n      ship,\n      url,\n      code\n    });\n  }\n\n}\n\nexport { FatalError, ResumableError, Urbit, Urbit as default };","map":{"version":3,"mappings":"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","names":["ResumableError","Error","FatalError","Object","defineProperty","lib","value","_typeof","Symbol","iterator","obj","constructor","prototype","isBrowser","window","document","isWebWorker","self","name","isNode","process","versions","node","isJsDom","navigator","userAgent","includes","getBytes","stream","onChunk","reader","getReader","result","read","done","getLines","onLine","buffer","position","fieldLength","discardTrailingNewline","arr","undefined","concat","bufLength","length","lineStart","lineEnd","subarray","getMessages","onId","onRetry","onMessage","message","newMessage","decoder","TextDecoder","line","field","decode","valueOffset","data","event","id","retry","parseInt","isNaN","a","b","res","Uint8Array","set","__rest","this","s","e","t","p","hasOwnProperty","call","indexOf","getOwnPropertySymbols","i","propertyIsEnumerable","EventStreamContentType","DefaultRetryInterval","LastEventId","fetchEventSource","input","_a","signal","inputSignal","headers","inputHeaders","onopen","inputOnOpen","onmessage","onclose","onerror","openWhenHidden","fetch","inputFetch","rest","Promise","resolve","reject","assign","accept","curRequestController","onVisibilityChange","abort","hidden","create","addEventListener","retryInterval","retryTimer","dispose","removeEventListener","clearTimeout","defaultOnOpen","AbortController","response","body","err","aborted","interval","setTimeout","innerErr","contentType","get","startsWith","hexString","len","maxlen","min","Math","pow","max","n","floor","random","r","toString","Urbit","url","code","desk","Date","now","Map","delete","channelUrl","uid","fetchOptions","Cookie","cookie","credentials","authenticate","ship","verbose","airlock","connect","poke","app","mark","json","eventSource","console","log","method","then","RegExp","exec","sseClientInitialized","lastEventId","ok","errorCount","onOpen","lastAcknowledgedEventId","ack","JSON","parse","outstandingPokes","has","funcs","onSuccess","error","onError","outstandingSubscriptions","quit","keys","warn","reset","getEventId","Number","eventId","action","sendJSONtoChannel","stringify","subscribeOnce","path","timeout","unsubscribe","request","subscribe","params","send","all","subscription","sendBeacon","scry","thread","inputMark","outputMark","threadName","onArvoNetwork"],"sources":["/home/mike/proj/frontend/ui/node_modules/@urbit/http-api/src/types.ts","/home/mike/proj/frontend/ui/node_modules/@urbit/http-api/node_modules/browser-or-node/lib/index.js","/home/mike/proj/frontend/ui/node_modules/@urbit/http-api/node_modules/@microsoft/fetch-event-source/lib/esm/parse.js","/home/mike/proj/frontend/ui/node_modules/@urbit/http-api/node_modules/@microsoft/fetch-event-source/lib/esm/fetch.js","/home/mike/proj/frontend/ui/node_modules/@urbit/http-api/src/utils.ts","/home/mike/proj/frontend/ui/node_modules/@urbit/http-api/src/Urbit.ts"],"sourcesContent":["/**\n * An urbit style path, rendered as a Javascript string\n * @example\n * `\"/updates\"`\n */\nexport type Path = string;\n\n/**\n * @p including leading sig, rendered as a string\n *\n * @example\n * ```typescript\n * \"~sampel-palnet\"\n * ```\n *\n */\nexport type Patp = string;\n\n/**\n * @p not including leading sig, rendered as a string\n *\n * @example\n * ```typescript\n * \"sampel-palnet\"\n * ```\n *\n */\nexport type PatpNoSig = string;\n\n/**\n * The name of a clay mark, as a string\n *\n * @example\n * ```typescript\n * \"graph-update\"\n * ```\n */\nexport type Mark = string;\n\n/**\n * The name of a gall agent, as a string\n *\n * @example\n *\n * ```typescript\n * \"graph-store\"\n * ```\n */\nexport type GallAgent = string;\n\n/**\n * Description of an outgoing poke\n *\n * @typeParam Action - Typescript type of the data being poked\n */\nexport interface Poke<Action> {\n  /**\n   * Ship to poke. If left empty, the api lib will populate it with the ship that it is connected to.\n   *\n   * @remarks\n   *\n   * This should always be the ship that you are connected to\n   *\n   */\n  ship?: PatpNoSig;\n  /**\n   */\n  app: GallAgent;\n  /**\n   * Mark of the cage to be poked\n   *\n   */\n  mark: Mark;\n  /**\n   * Vase of the cage of to be poked, as JSON\n   */\n  json: Action;\n}\n\n/**\n * Description of a scry request\n */\nexport interface Scry {\n  /** {@inheritDoc GallAgent} */\n  app: GallAgent;\n  /** {@inheritDoc Path} */\n  path: Path;\n}\n\n/**\n * Description of a thread request\n *\n * @typeParam Action - Typescript type of the data being poked\n */\nexport interface Thread<Action> {\n  /**\n   * The mark of the input vase\n   */\n  inputMark: Mark;\n  /**\n   * The mark of the output vase\n   */\n  outputMark: Mark;\n  /**\n   * Name of the thread\n   *\n   * @example\n   * ```typescript\n   * \"graph-add-nodes\"\n   * ```\n   */\n  threadName: string;\n  /**\n   * Desk of thread\n   */\n  desk?: string;\n  /**\n   * Data of the input vase\n   */\n  body: Action;\n}\n\nexport type Action = 'poke' | 'subscribe' | 'ack' | 'unsubscribe' | 'delete';\n\nexport interface PokeHandlers {\n  onSuccess?: () => void;\n  onError?: (e: any) => void;\n}\n\nexport type PokeInterface<T> = PokeHandlers & Poke<T>;\n\nexport interface AuthenticationInterface {\n  ship: string;\n  url: string;\n  code: string;\n  verbose?: boolean;\n}\n\n/**\n * Subscription event handlers\n *\n */\nexport interface SubscriptionInterface {\n  /**\n   * Handle negative %watch-ack\n   */\n  err?(error: any, id: string): void;\n  /**\n   * Handle %fact\n   */\n  event?(data: any): void;\n  /**\n   * Handle %kick\n   */\n  quit?(data: any): void;\n}\n\nexport type OnceSubscriptionErr = 'quit' | 'nack' | 'timeout';\n\nexport interface SubscriptionRequestInterface extends SubscriptionInterface {\n  /**\n   * The app to subscribe to\n   * @example\n   * `\"graph-store\"`\n   */\n  app: GallAgent;\n  /**\n   * The path to which to subscribe\n   * @example\n   * `\"/keys\"`\n   */\n  path: Path;\n}\n\nexport interface headers {\n  'Content-Type': string;\n  Cookie?: string;\n}\n\nexport interface CustomEventHandler {\n  (data: any, response: string): void;\n}\n\nexport interface SSEOptions {\n  headers?: {\n    Cookie?: string;\n  };\n  withCredentials?: boolean;\n}\n\nexport interface Message extends Record<string, any> {\n  action: Action;\n  id?: number;\n}\n\nexport class ResumableError extends Error {}\n\nexport class FatalError extends Error {}\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/* global window self */\n\nvar isBrowser = typeof window !== 'undefined' && typeof window.document !== 'undefined';\n\n/* eslint-disable no-restricted-globals */\nvar isWebWorker = (typeof self === 'undefined' ? 'undefined' : _typeof(self)) === 'object' && self.constructor && self.constructor.name === 'DedicatedWorkerGlobalScope';\n/* eslint-enable no-restricted-globals */\n\nvar isNode = typeof process !== 'undefined' && process.versions != null && process.versions.node != null;\n\n/**\n * @see https://github.com/jsdom/jsdom/releases/tag/12.0.0\n * @see https://github.com/jsdom/jsdom/issues/1537\n */\n/* eslint-disable no-undef */\nvar isJsDom = function isJsDom() {\n  return typeof window !== 'undefined' && window.name === 'nodejs' || navigator.userAgent.includes('Node.js') || navigator.userAgent.includes('jsdom');\n};\n\nexports.isBrowser = isBrowser;\nexports.isWebWorker = isWebWorker;\nexports.isNode = isNode;\nexports.isJsDom = isJsDom;","export async function getBytes(stream, onChunk) {\r\n    const reader = stream.getReader();\r\n    let result;\r\n    while (!(result = await reader.read()).done) {\r\n        onChunk(result.value);\r\n    }\r\n}\r\nexport function getLines(onLine) {\r\n    let buffer;\r\n    let position;\r\n    let fieldLength;\r\n    let discardTrailingNewline = false;\r\n    return function onChunk(arr) {\r\n        if (buffer === undefined) {\r\n            buffer = arr;\r\n            position = 0;\r\n            fieldLength = -1;\r\n        }\r\n        else {\r\n            buffer = concat(buffer, arr);\r\n        }\r\n        const bufLength = buffer.length;\r\n        let lineStart = 0;\r\n        while (position < bufLength) {\r\n            if (discardTrailingNewline) {\r\n                if (buffer[position] === 10) {\r\n                    lineStart = ++position;\r\n                }\r\n                discardTrailingNewline = false;\r\n            }\r\n            let lineEnd = -1;\r\n            for (; position < bufLength && lineEnd === -1; ++position) {\r\n                switch (buffer[position]) {\r\n                    case 58:\r\n                        if (fieldLength === -1) {\r\n                            fieldLength = position - lineStart;\r\n                        }\r\n                        break;\r\n                    case 13:\r\n                        discardTrailingNewline = true;\r\n                    case 10:\r\n                        lineEnd = position;\r\n                        break;\r\n                }\r\n            }\r\n            if (lineEnd === -1) {\r\n                break;\r\n            }\r\n            onLine(buffer.subarray(lineStart, lineEnd), fieldLength);\r\n            lineStart = position;\r\n            fieldLength = -1;\r\n        }\r\n        if (lineStart === bufLength) {\r\n            buffer = undefined;\r\n        }\r\n        else if (lineStart !== 0) {\r\n            buffer = buffer.subarray(lineStart);\r\n            position -= lineStart;\r\n        }\r\n    };\r\n}\r\nexport function getMessages(onId, onRetry, onMessage) {\r\n    let message = newMessage();\r\n    const decoder = new TextDecoder();\r\n    return function onLine(line, fieldLength) {\r\n        if (line.length === 0) {\r\n            onMessage === null || onMessage === void 0 ? void 0 : onMessage(message);\r\n            message = newMessage();\r\n        }\r\n        else if (fieldLength > 0) {\r\n            const field = decoder.decode(line.subarray(0, fieldLength));\r\n            const valueOffset = fieldLength + (line[fieldLength + 1] === 32 ? 2 : 1);\r\n            const value = decoder.decode(line.subarray(valueOffset));\r\n            switch (field) {\r\n                case 'data':\r\n                    message.data = message.data\r\n                        ? message.data + '\\n' + value\r\n                        : value;\r\n                    break;\r\n                case 'event':\r\n                    message.event = value;\r\n                    break;\r\n                case 'id':\r\n                    onId(message.id = value);\r\n                    break;\r\n                case 'retry':\r\n                    const retry = parseInt(value, 10);\r\n                    if (!isNaN(retry)) {\r\n                        onRetry(message.retry = retry);\r\n                    }\r\n                    break;\r\n            }\r\n        }\r\n    };\r\n}\r\nfunction concat(a, b) {\r\n    const res = new Uint8Array(a.length + b.length);\r\n    res.set(a);\r\n    res.set(b, a.length);\r\n    return res;\r\n}\r\nfunction newMessage() {\r\n    return {\r\n        data: '',\r\n        event: '',\r\n        id: '',\r\n        retry: undefined,\r\n    };\r\n}\r\n//# sourceMappingURL=parse.js.map","var __rest = (this && this.__rest) || function (s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n};\r\nimport { getBytes, getLines, getMessages } from './parse';\r\nexport const EventStreamContentType = 'text/event-stream';\r\nconst DefaultRetryInterval = 1000;\r\nconst LastEventId = 'last-event-id';\r\nexport function fetchEventSource(input, _a) {\r\n    var { signal: inputSignal, headers: inputHeaders, onopen: inputOnOpen, onmessage, onclose, onerror, openWhenHidden, fetch: inputFetch } = _a, rest = __rest(_a, [\"signal\", \"headers\", \"onopen\", \"onmessage\", \"onclose\", \"onerror\", \"openWhenHidden\", \"fetch\"]);\r\n    return new Promise((resolve, reject) => {\r\n        const headers = Object.assign({}, inputHeaders);\r\n        if (!headers.accept) {\r\n            headers.accept = EventStreamContentType;\r\n        }\r\n        let curRequestController;\r\n        function onVisibilityChange() {\r\n            curRequestController.abort();\r\n            if (!document.hidden) {\r\n                create();\r\n            }\r\n        }\r\n        if (!openWhenHidden) {\r\n            document.addEventListener('visibilitychange', onVisibilityChange);\r\n        }\r\n        let retryInterval = DefaultRetryInterval;\r\n        let retryTimer = 0;\r\n        function dispose() {\r\n            document.removeEventListener('visibilitychange', onVisibilityChange);\r\n            window.clearTimeout(retryTimer);\r\n            curRequestController.abort();\r\n        }\r\n        inputSignal === null || inputSignal === void 0 ? void 0 : inputSignal.addEventListener('abort', () => {\r\n            dispose();\r\n            resolve();\r\n        });\r\n        const fetch = inputFetch !== null && inputFetch !== void 0 ? inputFetch : window.fetch;\r\n        const onopen = inputOnOpen !== null && inputOnOpen !== void 0 ? inputOnOpen : defaultOnOpen;\r\n        async function create() {\r\n            var _a;\r\n            curRequestController = new AbortController();\r\n            try {\r\n                const response = await fetch(input, Object.assign(Object.assign({}, rest), { headers, signal: curRequestController.signal }));\r\n                await onopen(response);\r\n                await getBytes(response.body, getLines(getMessages(id => {\r\n                    if (id) {\r\n                        headers[LastEventId] = id;\r\n                    }\r\n                    else {\r\n                        delete headers[LastEventId];\r\n                    }\r\n                }, retry => {\r\n                    retryInterval = retry;\r\n                }, onmessage)));\r\n                onclose === null || onclose === void 0 ? void 0 : onclose();\r\n                dispose();\r\n                resolve();\r\n            }\r\n            catch (err) {\r\n                if (!curRequestController.signal.aborted) {\r\n                    try {\r\n                        const interval = (_a = onerror === null || onerror === void 0 ? void 0 : onerror(err)) !== null && _a !== void 0 ? _a : retryInterval;\r\n                        window.clearTimeout(retryTimer);\r\n                        retryTimer = window.setTimeout(create, interval);\r\n                    }\r\n                    catch (innerErr) {\r\n                        dispose();\r\n                        reject(innerErr);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        create();\r\n    });\r\n}\r\nfunction defaultOnOpen(response) {\r\n    const contentType = response.headers.get('content-type');\r\n    if (!(contentType === null || contentType === void 0 ? void 0 : contentType.startsWith(EventStreamContentType))) {\r\n        throw new Error(`Expected content-type to be ${EventStreamContentType}, Actual: ${contentType}`);\r\n    }\r\n}\r\n//# sourceMappingURL=fetch.js.map","export function camelize(str: string) {\n  return str\n    .replace(/\\s(.)/g, function ($1: string) {\n      return $1.toUpperCase();\n    })\n    .replace(/\\s/g, '')\n    .replace(/^(.)/, function ($1: string) {\n      return $1.toLowerCase();\n    });\n}\n\nexport function uncamelize(str: string, separator = '-') {\n  // Replace all capital letters by separator followed by lowercase one\n  var str = str.replace(/[A-Z]/g, function (letter: string) {\n    return separator + letter.toLowerCase();\n  });\n  return str.replace(new RegExp('^' + separator), '');\n}\n\n/**\n * Returns a hex string of given length.\n *\n * Poached from StackOverflow.\n *\n * @param len Length of hex string to return.\n */\nexport function hexString(len: number): string {\n  const maxlen = 8;\n  const min = Math.pow(16, Math.min(len, maxlen) - 1);\n  const max = Math.pow(16, Math.min(len, maxlen)) - 1;\n  const n = Math.floor(Math.random() * (max - min + 1)) + min;\n  let r = n.toString(16);\n  while (r.length < len) {\n    r = r + hexString(len - maxlen);\n  }\n  return r;\n}\n\n/**\n * Generates a random UID.\n *\n * Copied from https://github.com/urbit/urbit/blob/137e4428f617c13f28ed31e520eff98d251ed3e9/pkg/interface/src/lib/util.js#L3\n */\nexport function uid(): string {\n  let str = '0v';\n  str += Math.ceil(Math.random() * 8) + '.';\n  for (let i = 0; i < 5; i++) {\n    let _str = Math.ceil(Math.random() * 10000000).toString(32);\n    _str = ('00000' + _str).substr(-5, 5);\n    str += _str + '.';\n  }\n  return str.slice(0, -1);\n}\n","import { isBrowser, isNode } from 'browser-or-node';\nimport {\n  fetchEventSource,\n  EventSourceMessage,\n} from '@microsoft/fetch-event-source';\n\nimport {\n  Scry,\n  Thread,\n  AuthenticationInterface,\n  PokeInterface,\n  SubscriptionRequestInterface,\n  headers,\n  SSEOptions,\n  PokeHandlers,\n  Message,\n} from './types';\nimport { hexString } from './utils';\n\n/**\n * A class for interacting with an urbit ship, given its URL and code\n */\nexport class Urbit {\n  /**\n   * UID will be used for the channel: The current unix time plus a random hex string\n   */\n  private uid: string = `${Math.floor(Date.now() / 1000)}-${hexString(6)}`;\n\n  /**\n   * Last Event ID is an auto-updated index of which events have been sent over this channel\n   */\n  private lastEventId: number = 0;\n\n  private lastAcknowledgedEventId: number = 0;\n\n  /**\n   * SSE Client is null for now; we don't want to start polling until it the channel exists\n   */\n  private sseClientInitialized: boolean = false;\n\n  /**\n   * Cookie gets set when we log in.\n   */\n  cookie?: string | undefined;\n\n  /**\n   * A registry of requestId to successFunc/failureFunc\n   *\n   * These functions are registered during a +poke and are executed\n   * in the onServerEvent()/onServerError() callbacks. Only one of\n   * the functions will be called, and the outstanding poke will be\n   * removed after calling the success or failure function.\n   */\n\n  private outstandingPokes: Map<number, PokeHandlers> = new Map();\n\n  /**\n   * A registry of requestId to subscription functions.\n   *\n   * These functions are registered during a +subscribe and are\n   * executed in the onServerEvent()/onServerError() callbacks. The\n   * event function will be called whenever a new piece of data on this\n   * subscription is available, which may be 0, 1, or many times. The\n   * disconnect function may be called exactly once.\n   */\n  private outstandingSubscriptions: Map<number, SubscriptionRequestInterface> =\n    new Map();\n\n  /**\n   * Our abort controller, used to close the connection\n   */\n  private abort = new AbortController();\n\n  /**\n   * Ship can be set, in which case we can do some magic stuff like send chats\n   */\n  ship?: string | null;\n\n  /**\n   * If verbose, logs output eagerly.\n   */\n  verbose?: boolean;\n\n  /**\n   * number of consecutive errors in connecting to the eventsource\n   */\n  private errorCount = 0;\n\n  onError?: (error: any) => void = null;\n\n  onRetry?: () => void = null;\n\n  onOpen?: () => void = null;\n\n  /** This is basic interpolation to get the channel URL of an instantiated Urbit connection. */\n  private get channelUrl(): string {\n    return `${this.url}/~/channel/${this.uid}`;\n  }\n\n  private get fetchOptions(): any {\n    const headers: headers = {\n      'Content-Type': 'application/json',\n    };\n    if (!isBrowser) {\n      headers.Cookie = this.cookie;\n    }\n    return {\n      credentials: 'include',\n      accept: '*',\n      headers,\n      signal: this.abort.signal,\n    };\n  }\n\n  /**\n   * Constructs a new Urbit connection.\n   *\n   * @param url  The URL (with protocol and port) of the ship to be accessed. If\n   * the airlock is running in a webpage served by the ship, this should just\n   * be the empty string.\n   * @param code The access code for the ship at that address\n   */\n  constructor(public url: string, public code?: string, public desk?: string) {\n    if (isBrowser) {\n      window.addEventListener('beforeunload', this.delete);\n    }\n    return this;\n  }\n\n  /**\n   * All-in-one hook-me-up.\n   *\n   * Given a ship, url, and code, this returns an airlock connection\n   * that is ready to go. It `|hi`s itself to create the channel,\n   * then opens the channel via EventSource.\n   *\n   */\n  static async authenticate({\n    ship,\n    url,\n    code,\n    verbose = false,\n  }: AuthenticationInterface) {\n    const airlock = new Urbit(`http://${url}`, code);\n    airlock.verbose = verbose;\n    airlock.ship = ship;\n    await airlock.connect();\n    await airlock.poke({\n      app: 'hood',\n      mark: 'helm-hi',\n      json: 'opening airlock',\n    });\n    await airlock.eventSource();\n    return airlock;\n  }\n\n  /**\n   * Connects to the Urbit ship. Nothing can be done until this is called.\n   * That's why we roll it into this.authenticate\n   */\n  async connect(): Promise<void> {\n    if (this.verbose) {\n      console.log(\n        `password=${this.code} `,\n        isBrowser\n          ? 'Connecting in browser context at ' + `${this.url}/~/login`\n          : 'Connecting from node context'\n      );\n    }\n    return fetch(`${this.url}/~/login`, {\n      method: 'post',\n      body: `password=${this.code}`,\n      credentials: 'include',\n    }).then((response) => {\n      if (this.verbose) {\n        console.log('Received authentication response', response);\n      }\n      const cookie = response.headers.get('set-cookie');\n      if (!this.ship) {\n        this.ship = new RegExp(/urbauth-~([\\w-]+)/).exec(cookie)[1];\n      }\n      if (!isBrowser) {\n        this.cookie = cookie;\n      }\n    });\n  }\n\n  /**\n   * Initializes the SSE pipe for the appropriate channel.\n   */\n  async eventSource(): Promise<void> {\n    if (this.sseClientInitialized) {\n      return Promise.resolve();\n    }\n    if (this.lastEventId === 0) {\n      // Can't receive events until the channel is open,\n      // so poke and open then\n      await this.poke({\n        app: 'hood',\n        mark: 'helm-hi',\n        json: 'Opening API channel',\n      });\n      return;\n    }\n    this.sseClientInitialized = true;\n    return new Promise((resolve, reject) => {\n      const sseOptions: SSEOptions = {\n        headers: {},\n      };\n      if (isBrowser) {\n        sseOptions.withCredentials = true;\n      } else if (isNode) {\n        sseOptions.headers.Cookie = this.cookie;\n      }\n      fetchEventSource(this.channelUrl, {\n        ...this.fetchOptions,\n        openWhenHidden: true,\n        onopen: async (response) => {\n          if (this.verbose) {\n            console.log('Opened eventsource', response);\n          }\n          if (response.ok) {\n            this.errorCount = 0;\n            this.onOpen && this.onOpen();\n            resolve();\n            return; // everything's good\n          } else {\n            const err = new Error('failed to open eventsource');\n            reject(err);\n          }\n        },\n        onmessage: (event: EventSourceMessage) => {\n          if (this.verbose) {\n            console.log('Received SSE: ', event);\n          }\n          if (!event.id) return;\n          this.lastEventId = parseInt(event.id, 10);\n          if (this.lastEventId - this.lastAcknowledgedEventId > 20) {\n            this.ack(this.lastEventId);\n          }\n\n          if (event.data && JSON.parse(event.data)) {\n            const data: any = JSON.parse(event.data);\n\n            if (\n              data.response === 'poke' &&\n              this.outstandingPokes.has(data.id)\n            ) {\n              const funcs = this.outstandingPokes.get(data.id);\n              if (data.hasOwnProperty('ok')) {\n                funcs.onSuccess();\n              } else if (data.hasOwnProperty('err')) {\n                console.error(data.err);\n                funcs.onError(data.err);\n              } else {\n                console.error('Invalid poke response', data);\n              }\n              this.outstandingPokes.delete(data.id);\n            } else if (\n              data.response === 'subscribe' &&\n              this.outstandingSubscriptions.has(data.id)\n            ) {\n              const funcs = this.outstandingSubscriptions.get(data.id);\n              if (data.hasOwnProperty('err')) {\n                console.error(data.err);\n                funcs.err(data.err, data.id);\n                this.outstandingSubscriptions.delete(data.id);\n              }\n            } else if (\n              data.response === 'diff' &&\n              this.outstandingSubscriptions.has(data.id)\n            ) {\n              const funcs = this.outstandingSubscriptions.get(data.id);\n              try {\n                funcs.event(data.json);\n              } catch (e) {\n                console.error('Failed to call subscription event callback', e);\n              }\n            } else if (\n              data.response === 'quit' &&\n              this.outstandingSubscriptions.has(data.id)\n            ) {\n              const funcs = this.outstandingSubscriptions.get(data.id);\n              funcs.quit(data);\n              this.outstandingSubscriptions.delete(data.id);\n            } else {\n              console.log([...this.outstandingSubscriptions.keys()]);\n              console.log('Unrecognized response', data);\n            }\n          }\n        },\n        onerror: (error) => {\n          console.warn(error);\n          if (this.errorCount++ < 4) {\n            this.onRetry && this.onRetry();\n            return Math.pow(2, this.errorCount - 1) * 750;\n          }\n          this.onError && this.onError(error);\n          throw error;\n        },\n        onclose: () => {\n          console.log('e');\n          throw new Error('Ship unexpectedly closed the connection');\n        },\n      });\n    });\n  }\n\n  /**\n   * Reset airlock, abandoning current subscriptions and wiping state\n   *\n   */\n  reset() {\n    this.delete();\n    this.abort.abort();\n    this.abort = new AbortController();\n    this.uid = `${Math.floor(Date.now() / 1000)}-${hexString(6)}`;\n    this.lastEventId = 0;\n    this.lastAcknowledgedEventId = 0;\n    this.outstandingSubscriptions = new Map();\n    this.outstandingPokes = new Map();\n    this.sseClientInitialized = false;\n  }\n\n  /**\n   * Autoincrements the next event ID for the appropriate channel.\n   */\n  private getEventId(): number {\n    this.lastEventId = Number(this.lastEventId) + 1;\n    return this.lastEventId;\n  }\n\n  /**\n   * Acknowledges an event.\n   *\n   * @param eventId The event to acknowledge.\n   */\n  private async ack(eventId: number): Promise<number | void> {\n    this.lastAcknowledgedEventId = eventId;\n    const message: Message = {\n      action: 'ack',\n      'event-id': eventId,\n    };\n    await this.sendJSONtoChannel(message);\n    return eventId;\n  }\n\n  private async sendJSONtoChannel(...json: Message[]): Promise<void> {\n    const response = await fetch(this.channelUrl, {\n      ...this.fetchOptions,\n      method: 'PUT',\n      body: JSON.stringify(json),\n    });\n    if (!response.ok) {\n      throw new Error('Failed to PUT channel');\n    }\n    if (!this.sseClientInitialized) {\n      await this.eventSource();\n    }\n  }\n\n  /**\n   * Creates a subscription, waits for a fact and then unsubscribes\n   *\n   * @param app Name of gall agent to subscribe to\n   * @param path Path to subscribe to\n   * @param timeout Optional timeout before ending subscription\n   *\n   * @returns The first fact on the subcription\n   */\n  async subscribeOnce<T = any>(app: string, path: string, timeout?: number) {\n    return new Promise<T>(async (resolve, reject) => {\n      let done = false;\n      let id: number | null = null;\n      const quit = () => {\n        if (!done) {\n          reject('quit');\n        }\n      };\n      const event = (e: T) => {\n        if (!done) {\n          resolve(e);\n          this.unsubscribe(id);\n        }\n      };\n      const request = { app, path, event, err: reject, quit };\n\n      id = await this.subscribe(request);\n\n      if (timeout) {\n        setTimeout(() => {\n          if (!done) {\n            done = true;\n            reject('timeout');\n            this.unsubscribe(id);\n          }\n        }, timeout);\n      }\n    });\n  }\n\n  /**\n   * Pokes a ship with data.\n   *\n   * @param app The app to poke\n   * @param mark The mark of the data being sent\n   * @param json The data to send\n   */\n  async poke<T>(params: PokeInterface<T>): Promise<number> {\n    const { app, mark, json, ship, onSuccess, onError } = {\n      onSuccess: () => {},\n      onError: () => {},\n      ship: this.ship,\n      ...params,\n    };\n    const message: Message = {\n      id: this.getEventId(),\n      action: 'poke',\n      ship,\n      app,\n      mark,\n      json,\n    };\n    const [send, result] = await Promise.all([\n      this.sendJSONtoChannel(message),\n      new Promise<number>((resolve, reject) => {\n        this.outstandingPokes.set(message.id, {\n          onSuccess: () => {\n            onSuccess();\n            resolve(message.id);\n          },\n          onError: (event) => {\n            onError(event);\n            reject(event.err);\n          },\n        });\n      }),\n    ]);\n    return result;\n  }\n\n  /**\n   * Subscribes to a path on an app on a ship.\n   *\n   *\n   * @param app The app to subsribe to\n   * @param path The path to which to subscribe\n   * @param handlers Handlers to deal with various events of the subscription\n   */\n  async subscribe(params: SubscriptionRequestInterface): Promise<number> {\n    const { app, path, ship, err, event, quit } = {\n      err: () => {},\n      event: () => {},\n      quit: () => {},\n      ship: this.ship,\n      ...params,\n    };\n\n    const message: Message = {\n      id: this.getEventId(),\n      action: 'subscribe',\n      ship,\n      app,\n      path,\n    };\n\n    this.outstandingSubscriptions.set(message.id, {\n      app,\n      path,\n      err,\n      event,\n      quit,\n    });\n\n    await this.sendJSONtoChannel(message);\n\n    return message.id;\n  }\n\n  /**\n   * Unsubscribes to a given subscription.\n   *\n   * @param subscription\n   */\n  async unsubscribe(subscription: number) {\n    return this.sendJSONtoChannel({\n      id: this.getEventId(),\n      action: 'unsubscribe',\n      subscription,\n    }).then(() => {\n      this.outstandingSubscriptions.delete(subscription);\n    });\n  }\n\n  /**\n   * Deletes the connection to a channel.\n   */\n  delete() {\n    if (isBrowser) {\n      navigator.sendBeacon(\n        this.channelUrl,\n        JSON.stringify([\n          {\n            action: 'delete',\n          },\n        ])\n      );\n    } else {\n      // TODO\n      // this.sendMessage('delete');\n    }\n  }\n\n  /**\n   * Scry into an gall agent at a path\n   *\n   * @typeParam T - Type of the scry result\n   *\n   * @remarks\n   *\n   * Equivalent to\n   * ```hoon\n   * .^(T %gx /(scot %p our)/[app]/(scot %da now)/[path]/json)\n   * ```\n   * The returned cage must have a conversion to JSON for the scry to succeed\n   *\n   * @param params The scry request\n   * @returns The scry result\n   */\n  async scry<T = any>(params: Scry): Promise<T> {\n    const { app, path } = params;\n    const response = await fetch(\n      `${this.url}/~/scry/${app}${path}.json`,\n      this.fetchOptions\n    );\n    return await response.json();\n  }\n\n  /**\n   * Run a thread\n   *\n   *\n   * @param inputMark   The mark of the data being sent\n   * @param outputMark  The mark of the data being returned\n   * @param threadName  The thread to run\n   * @param body        The data to send to the thread\n   * @returns  The return value of the thread\n   */\n  async thread<R, T = any>(params: Thread<T>): Promise<R> {\n    const {\n      inputMark,\n      outputMark,\n      threadName,\n      body,\n      desk = this.desk,\n    } = params;\n    if (!desk) {\n      throw new Error('Must supply desk to run thread from');\n    }\n    const res = await fetch(\n      `${this.url}/spider/${desk}/${inputMark}/${threadName}/${outputMark}.json`,\n      {\n        ...this.fetchOptions,\n        method: 'POST',\n        body: JSON.stringify(body),\n      }\n    );\n\n    return res.json();\n  }\n\n  /**\n   * Utility function to connect to a ship that has its *.arvo.network domain configured.\n   *\n   * @param name Name of the ship e.g. zod\n   * @param code Code to log in\n   */\n  static async onArvoNetwork(ship: string, code: string): Promise<Urbit> {\n    const url = `https://${ship}.arvo.network`;\n    return await Urbit.authenticate({ ship, url, code });\n  }\n}\n\nexport default Urbit;\n"]},"metadata":{},"sourceType":"module"}