{"ast":null,"code":"import _slicedToArray from \"/home/mike/proj/frontend/ui/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _toConsumableArray from \"/home/mike/proj/frontend/ui/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _objectSpread from \"/home/mike/proj/frontend/ui/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"/home/mike/proj/frontend/ui/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _createClass from \"/home/mike/proj/frontend/ui/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"/home/mike/proj/frontend/ui/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _inherits from \"/home/mike/proj/frontend/ui/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/home/mike/proj/frontend/ui/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _wrapNativeSuper from \"/home/mike/proj/frontend/ui/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js\";\nimport _regeneratorRuntime from \"/home/mike/proj/frontend/ui/node_modules/@babel/runtime/regenerator/index.js\";\n\nvar ResumableError = /*#__PURE__*/function (_Error) {\n  _inherits(ResumableError, _Error);\n\n  var _super = _createSuper(ResumableError);\n\n  function ResumableError() {\n    _classCallCheck(this, ResumableError);\n\n    return _super.apply(this, arguments);\n  }\n\n  return _createClass(ResumableError);\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nvar FatalError = /*#__PURE__*/function (_Error2) {\n  _inherits(FatalError, _Error2);\n\n  var _super2 = _createSuper(FatalError);\n\n  function FatalError() {\n    _classCallCheck(this, FatalError);\n\n    return _super2.apply(this, arguments);\n  }\n\n  return _createClass(FatalError);\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nvar lib = {};\nObject.defineProperty(lib, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n/* global window self */\n\n\nvar isBrowser = typeof window !== 'undefined' && typeof window.document !== 'undefined';\n/* eslint-disable no-restricted-globals */\n\nvar isWebWorker = (typeof self === 'undefined' ? 'undefined' : _typeof(self)) === 'object' && self.constructor && self.constructor.name === 'DedicatedWorkerGlobalScope';\n/* eslint-enable no-restricted-globals */\n\nvar isNode = typeof process !== 'undefined' && process.versions != null && process.versions.node != null;\n/**\n * @see https://github.com/jsdom/jsdom/releases/tag/12.0.0\n * @see https://github.com/jsdom/jsdom/issues/1537\n */\n\n/* eslint-disable no-undef */\n\nvar isJsDom = function isJsDom() {\n  return typeof window !== 'undefined' && window.name === 'nodejs' || navigator.userAgent.includes('Node.js') || navigator.userAgent.includes('jsdom');\n};\n\nvar isBrowser_1 = lib.isBrowser = isBrowser;\nlib.isWebWorker = isWebWorker;\nlib.isNode = isNode;\nlib.isJsDom = isJsDom;\n\nfunction getBytes(_x, _x2) {\n  return _getBytes.apply(this, arguments);\n}\n\nfunction _getBytes() {\n  _getBytes = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee16(stream, onChunk) {\n    var reader, result;\n    return _regeneratorRuntime.wrap(function _callee16$(_context16) {\n      while (1) {\n        switch (_context16.prev = _context16.next) {\n          case 0:\n            reader = stream.getReader();\n\n          case 1:\n            _context16.next = 3;\n            return reader.read();\n\n          case 3:\n            if ((result = _context16.sent).done) {\n              _context16.next = 7;\n              break;\n            }\n\n            onChunk(result.value);\n            _context16.next = 1;\n            break;\n\n          case 7:\n          case \"end\":\n            return _context16.stop();\n        }\n      }\n    }, _callee16);\n  }));\n  return _getBytes.apply(this, arguments);\n}\n\nfunction getLines(onLine) {\n  var buffer;\n  var position;\n  var fieldLength;\n  var discardTrailingNewline = false;\n  return function onChunk(arr) {\n    if (buffer === undefined) {\n      buffer = arr;\n      position = 0;\n      fieldLength = -1;\n    } else {\n      buffer = concat(buffer, arr);\n    }\n\n    var bufLength = buffer.length;\n    var lineStart = 0;\n\n    while (position < bufLength) {\n      if (discardTrailingNewline) {\n        if (buffer[position] === 10) {\n          lineStart = ++position;\n        }\n\n        discardTrailingNewline = false;\n      }\n\n      var lineEnd = -1;\n\n      for (; position < bufLength && lineEnd === -1; ++position) {\n        switch (buffer[position]) {\n          case 58:\n            if (fieldLength === -1) {\n              fieldLength = position - lineStart;\n            }\n\n            break;\n\n          case 13:\n            discardTrailingNewline = true;\n\n          case 10:\n            lineEnd = position;\n            break;\n        }\n      }\n\n      if (lineEnd === -1) {\n        break;\n      }\n\n      onLine(buffer.subarray(lineStart, lineEnd), fieldLength);\n      lineStart = position;\n      fieldLength = -1;\n    }\n\n    if (lineStart === bufLength) {\n      buffer = undefined;\n    } else if (lineStart !== 0) {\n      buffer = buffer.subarray(lineStart);\n      position -= lineStart;\n    }\n  };\n}\n\nfunction getMessages(onId, onRetry, onMessage) {\n  var message = newMessage();\n  var decoder = new TextDecoder();\n  return function onLine(line, fieldLength) {\n    if (line.length === 0) {\n      onMessage === null || onMessage === void 0 ? void 0 : onMessage(message);\n      message = newMessage();\n    } else if (fieldLength > 0) {\n      var field = decoder.decode(line.subarray(0, fieldLength));\n      var valueOffset = fieldLength + (line[fieldLength + 1] === 32 ? 2 : 1);\n      var value = decoder.decode(line.subarray(valueOffset));\n\n      switch (field) {\n        case 'data':\n          message.data = message.data ? message.data + '\\n' + value : value;\n          break;\n\n        case 'event':\n          message.event = value;\n          break;\n\n        case 'id':\n          onId(message.id = value);\n          break;\n\n        case 'retry':\n          var retry = parseInt(value, 10);\n\n          if (!isNaN(retry)) {\n            onRetry(message.retry = retry);\n          }\n\n          break;\n      }\n    }\n  };\n}\n\nfunction concat(a, b) {\n  var res = new Uint8Array(a.length + b.length);\n  res.set(a);\n  res.set(b, a.length);\n  return res;\n}\n\nfunction newMessage() {\n  return {\n    data: '',\n    event: '',\n    id: '',\n    retry: undefined\n  };\n}\n\nvar __rest = undefined && undefined.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nvar EventStreamContentType = 'text/event-stream';\nvar DefaultRetryInterval = 1000;\nvar LastEventId = 'last-event-id';\n\nfunction fetchEventSource(input, _a) {\n  var inputSignal = _a.signal,\n      inputHeaders = _a.headers,\n      inputOnOpen = _a.onopen,\n      onmessage = _a.onmessage,\n      onclose = _a.onclose,\n      onerror = _a.onerror,\n      openWhenHidden = _a.openWhenHidden,\n      inputFetch = _a.fetch,\n      rest = __rest(_a, [\"signal\", \"headers\", \"onopen\", \"onmessage\", \"onclose\", \"onerror\", \"openWhenHidden\", \"fetch\"]);\n\n  return new Promise(function (resolve, reject) {\n    var headers = Object.assign({}, inputHeaders);\n\n    if (!headers.accept) {\n      headers.accept = EventStreamContentType;\n    }\n\n    var curRequestController;\n\n    function onVisibilityChange() {\n      curRequestController.abort();\n\n      if (!document.hidden) {\n        create();\n      }\n    }\n\n    if (!openWhenHidden) {\n      document.addEventListener('visibilitychange', onVisibilityChange);\n    }\n\n    var retryInterval = DefaultRetryInterval;\n    var retryTimer = 0;\n\n    function dispose() {\n      document.removeEventListener('visibilitychange', onVisibilityChange);\n      window.clearTimeout(retryTimer);\n      curRequestController.abort();\n    }\n\n    inputSignal === null || inputSignal === void 0 ? void 0 : inputSignal.addEventListener('abort', function () {\n      dispose();\n      resolve();\n    });\n    var fetch = inputFetch !== null && inputFetch !== void 0 ? inputFetch : window.fetch;\n    var onopen = inputOnOpen !== null && inputOnOpen !== void 0 ? inputOnOpen : defaultOnOpen;\n\n    function create() {\n      return _create.apply(this, arguments);\n    }\n\n    function _create() {\n      _create = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var _a, response, interval;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                curRequestController = new AbortController();\n                _context.prev = 1;\n                _context.next = 4;\n                return fetch(input, Object.assign(Object.assign({}, rest), {\n                  headers: headers,\n                  signal: curRequestController.signal\n                }));\n\n              case 4:\n                response = _context.sent;\n                _context.next = 7;\n                return onopen(response);\n\n              case 7:\n                _context.next = 9;\n                return getBytes(response.body, getLines(getMessages(function (id) {\n                  if (id) {\n                    headers[LastEventId] = id;\n                  } else {\n                    delete headers[LastEventId];\n                  }\n                }, function (retry) {\n                  retryInterval = retry;\n                }, onmessage)));\n\n              case 9:\n                onclose === null || onclose === void 0 ? void 0 : onclose();\n                dispose();\n                resolve();\n                _context.next = 17;\n                break;\n\n              case 14:\n                _context.prev = 14;\n                _context.t0 = _context[\"catch\"](1);\n\n                if (!curRequestController.signal.aborted) {\n                  try {\n                    interval = (_a = onerror === null || onerror === void 0 ? void 0 : onerror(_context.t0)) !== null && _a !== void 0 ? _a : retryInterval;\n                    window.clearTimeout(retryTimer);\n                    retryTimer = window.setTimeout(create, interval);\n                  } catch (innerErr) {\n                    dispose();\n                    reject(innerErr);\n                  }\n                }\n\n              case 17:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, null, [[1, 14]]);\n      }));\n      return _create.apply(this, arguments);\n    }\n\n    create();\n  });\n}\n\nfunction defaultOnOpen(response) {\n  var contentType = response.headers.get('content-type');\n\n  if (!(contentType === null || contentType === void 0 ? void 0 : contentType.startsWith(EventStreamContentType))) {\n    throw new Error(\"Expected content-type to be \".concat(EventStreamContentType, \", Actual: \").concat(contentType));\n  }\n}\n/**\r\n * Returns a hex string of given length.\r\n *\r\n * Poached from StackOverflow.\r\n *\r\n * @param len Length of hex string to return.\r\n */\n\n\nfunction hexString(len) {\n  var maxlen = 8;\n  var min = Math.pow(16, Math.min(len, maxlen) - 1);\n  var max = Math.pow(16, Math.min(len, maxlen)) - 1;\n  var n = Math.floor(Math.random() * (max - min + 1)) + min;\n  var r = n.toString(16);\n\n  while (r.length < len) {\n    r = r + hexString(len - maxlen);\n  }\n\n  return r;\n}\n/**\r\n * A class for interacting with an urbit ship, given its URL and code\r\n */\n\n\nvar Urbit = /*#__PURE__*/function () {\n  /**\r\n   * Constructs a new Urbit connection.\r\n   *\r\n   * @param url  The URL (with protocol and port) of the ship to be accessed. If\r\n   * the airlock is running in a webpage served by the ship, this should just\r\n   * be the empty string.\r\n   * @param code The access code for the ship at that address\r\n   */\n  function Urbit(url, code, desk) {\n    _classCallCheck(this, Urbit);\n\n    this.url = url;\n    this.code = code;\n    this.desk = desk;\n    /**\r\n     * UID will be used for the channel: The current unix time plus a random hex string\r\n     */\n\n    this.uid = \"\".concat(Math.floor(Date.now() / 1000), \"-\").concat(hexString(6));\n    /**\r\n     * Last Event ID is an auto-updated index of which events have been sent over this channel\r\n     */\n\n    this.lastEventId = 0;\n    this.lastAcknowledgedEventId = 0;\n    /**\r\n     * SSE Client is null for now; we don't want to start polling until it the channel exists\r\n     */\n\n    this.sseClientInitialized = false;\n    /**\r\n     * A registry of requestId to successFunc/failureFunc\r\n     *\r\n     * These functions are registered during a +poke and are executed\r\n     * in the onServerEvent()/onServerError() callbacks. Only one of\r\n     * the functions will be called, and the outstanding poke will be\r\n     * removed after calling the success or failure function.\r\n     */\n\n    this.outstandingPokes = new Map();\n    /**\r\n     * A registry of requestId to subscription functions.\r\n     *\r\n     * These functions are registered during a +subscribe and are\r\n     * executed in the onServerEvent()/onServerError() callbacks. The\r\n     * event function will be called whenever a new piece of data on this\r\n     * subscription is available, which may be 0, 1, or many times. The\r\n     * disconnect function may be called exactly once.\r\n     */\n\n    this.outstandingSubscriptions = new Map();\n    /**\r\n     * Our abort controller, used to close the connection\r\n     */\n\n    this.abort = new AbortController();\n    /**\r\n     * number of consecutive errors in connecting to the eventsource\r\n     */\n\n    this.errorCount = 0;\n    this.onError = null;\n    this.onRetry = null;\n    this.onOpen = null;\n\n    if (isBrowser_1) {\n      window.addEventListener('beforeunload', this.delete);\n    }\n\n    return this;\n  }\n  /** This is basic interpolation to get the channel URL of an instantiated Urbit connection. */\n\n\n  _createClass(Urbit, [{\n    key: \"channelUrl\",\n    get: function get() {\n      return \"\".concat(this.url, \"/~/channel/\").concat(this.uid);\n    }\n  }, {\n    key: \"fetchOptions\",\n    get: function get() {\n      var headers = {\n        'Content-Type': 'application/json'\n      };\n\n      if (!isBrowser_1) {\n        headers.Cookie = this.cookie;\n      }\n\n      return {\n        credentials: 'include',\n        accept: '*',\n        headers: headers,\n        signal: this.abort.signal\n      };\n    }\n    /**\r\n     * All-in-one hook-me-up.\r\n     *\r\n     * Given a ship, url, and code, this returns an airlock connection\r\n     * that is ready to go. It `|hi`s itself to create the channel,\r\n     * then opens the channel via EventSource.\r\n     *\r\n     */\n\n  }, {\n    key: \"connect\",\n    value:\n    /**\r\n     * Connects to the Urbit ship. Nothing can be done until this is called.\r\n     * That's why we roll it into this.authenticate\r\n     */\n    function () {\n      var _connect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var _this = this;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (this.verbose) {\n                  console.log(\"password=\".concat(this.code, \" \"), isBrowser_1 ? 'Connecting in browser context at ' + \"\".concat(this.url, \"/~/login\") : 'Connecting from node context');\n                }\n\n                return _context2.abrupt(\"return\", fetch(\"\".concat(this.url, \"/~/login\"), {\n                  method: 'post',\n                  body: \"password=\".concat(this.code),\n                  credentials: 'include'\n                }).then(function (response) {\n                  if (_this.verbose) {\n                    console.log('Received authentication response', response);\n                  }\n\n                  var cookie = response.headers.get('set-cookie');\n\n                  if (!_this.ship) {\n                    _this.ship = new RegExp(/urbauth-~([\\w-]+)/).exec(cookie)[1];\n                  }\n\n                  if (!isBrowser_1) {\n                    _this.cookie = cookie;\n                  }\n                }));\n\n              case 2:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function connect() {\n        return _connect.apply(this, arguments);\n      }\n\n      return connect;\n    }()\n    /**\r\n     * Initializes the SSE pipe for the appropriate channel.\r\n     */\n\n  }, {\n    key: \"eventSource\",\n    value: function () {\n      var _eventSource = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        var _this2 = this;\n\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (!this.sseClientInitialized) {\n                  _context4.next = 2;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\", Promise.resolve());\n\n              case 2:\n                if (!(this.lastEventId === 0)) {\n                  _context4.next = 6;\n                  break;\n                }\n\n                _context4.next = 5;\n                return this.poke({\n                  app: 'hood',\n                  mark: 'helm-hi',\n                  json: 'Opening API channel'\n                });\n\n              case 5:\n                return _context4.abrupt(\"return\");\n\n              case 6:\n                this.sseClientInitialized = true;\n                return _context4.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  fetchEventSource(_this2.channelUrl, _objectSpread(_objectSpread({}, _this2.fetchOptions), {}, {\n                    openWhenHidden: true,\n                    onopen: function () {\n                      var _onopen = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(response) {\n                        var err;\n                        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n                          while (1) {\n                            switch (_context3.prev = _context3.next) {\n                              case 0:\n                                if (_this2.verbose) {\n                                  console.log('Opened eventsource', response);\n                                }\n\n                                if (!response.ok) {\n                                  _context3.next = 8;\n                                  break;\n                                }\n\n                                _this2.errorCount = 0;\n                                _this2.onOpen && _this2.onOpen();\n                                resolve();\n                                return _context3.abrupt(\"return\");\n\n                              case 8:\n                                err = new Error('failed to open eventsource');\n                                reject(err);\n\n                              case 10:\n                              case \"end\":\n                                return _context3.stop();\n                            }\n                          }\n                        }, _callee3);\n                      }));\n\n                      function onopen(_x3) {\n                        return _onopen.apply(this, arguments);\n                      }\n\n                      return onopen;\n                    }(),\n                    onmessage: function onmessage(event) {\n                      if (_this2.verbose) {\n                        console.log('Received SSE: ', event);\n                      }\n\n                      if (!event.id) return;\n                      _this2.lastEventId = parseInt(event.id, 10);\n\n                      if (_this2.lastEventId - _this2.lastAcknowledgedEventId > 20) {\n                        _this2.ack(_this2.lastEventId);\n                      }\n\n                      if (event.data && JSON.parse(event.data)) {\n                        var data = JSON.parse(event.data);\n\n                        if (data.response === 'poke' && _this2.outstandingPokes.has(data.id)) {\n                          var funcs = _this2.outstandingPokes.get(data.id);\n\n                          if (data.hasOwnProperty('ok')) {\n                            funcs.onSuccess();\n                          } else if (data.hasOwnProperty('err')) {\n                            console.error(data.err);\n                            funcs.onError(data.err);\n                          } else {\n                            console.error('Invalid poke response', data);\n                          }\n\n                          _this2.outstandingPokes.delete(data.id);\n                        } else if (data.response === 'subscribe' && _this2.outstandingSubscriptions.has(data.id)) {\n                          var _funcs = _this2.outstandingSubscriptions.get(data.id);\n\n                          if (data.hasOwnProperty('err')) {\n                            console.error(data.err);\n\n                            _funcs.err(data.err, data.id);\n\n                            _this2.outstandingSubscriptions.delete(data.id);\n                          }\n                        } else if (data.response === 'diff' && _this2.outstandingSubscriptions.has(data.id)) {\n                          var _funcs2 = _this2.outstandingSubscriptions.get(data.id);\n\n                          try {\n                            _funcs2.event(data.json);\n                          } catch (e) {\n                            console.error('Failed to call subscription event callback', e);\n                          }\n                        } else if (data.response === 'quit' && _this2.outstandingSubscriptions.has(data.id)) {\n                          var _funcs3 = _this2.outstandingSubscriptions.get(data.id);\n\n                          _funcs3.quit(data);\n\n                          _this2.outstandingSubscriptions.delete(data.id);\n                        } else {\n                          console.log(_toConsumableArray(_this2.outstandingSubscriptions.keys()));\n                          console.log('Unrecognized response', data);\n                        }\n                      }\n                    },\n                    onerror: function onerror(error) {\n                      console.warn(error);\n\n                      if (_this2.errorCount++ < 4) {\n                        _this2.onRetry && _this2.onRetry();\n                        return Math.pow(2, _this2.errorCount - 1) * 750;\n                      }\n\n                      _this2.onError && _this2.onError(error);\n                      throw error;\n                    },\n                    onclose: function onclose() {\n                      console.log('e');\n                      throw new Error('Ship unexpectedly closed the connection');\n                    }\n                  }));\n                }));\n\n              case 8:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function eventSource() {\n        return _eventSource.apply(this, arguments);\n      }\n\n      return eventSource;\n    }()\n    /**\r\n     * Reset airlock, abandoning current subscriptions and wiping state\r\n     *\r\n     */\n\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.delete();\n      this.abort.abort();\n      this.abort = new AbortController();\n      this.uid = \"\".concat(Math.floor(Date.now() / 1000), \"-\").concat(hexString(6));\n      this.lastEventId = 0;\n      this.lastAcknowledgedEventId = 0;\n      this.outstandingSubscriptions = new Map();\n      this.outstandingPokes = new Map();\n      this.sseClientInitialized = false;\n    }\n    /**\r\n     * Autoincrements the next event ID for the appropriate channel.\r\n     */\n\n  }, {\n    key: \"getEventId\",\n    value: function getEventId() {\n      this.lastEventId = Number(this.lastEventId) + 1;\n      return this.lastEventId;\n    }\n    /**\r\n     * Acknowledges an event.\r\n     *\r\n     * @param eventId The event to acknowledge.\r\n     */\n\n  }, {\n    key: \"ack\",\n    value: function () {\n      var _ack = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(eventId) {\n        var message;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                this.lastAcknowledgedEventId = eventId;\n                message = {\n                  action: 'ack',\n                  'event-id': eventId\n                };\n                _context5.next = 4;\n                return this.sendJSONtoChannel(message);\n\n              case 4:\n                return _context5.abrupt(\"return\", eventId);\n\n              case 5:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function ack(_x4) {\n        return _ack.apply(this, arguments);\n      }\n\n      return ack;\n    }()\n  }, {\n    key: \"sendJSONtoChannel\",\n    value: function () {\n      var _sendJSONtoChannel = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {\n        var _len,\n            json,\n            _key,\n            response,\n            _args6 = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                for (_len = _args6.length, json = new Array(_len), _key = 0; _key < _len; _key++) {\n                  json[_key] = _args6[_key];\n                }\n\n                _context6.next = 3;\n                return fetch(this.channelUrl, _objectSpread(_objectSpread({}, this.fetchOptions), {}, {\n                  method: 'PUT',\n                  body: JSON.stringify(json)\n                }));\n\n              case 3:\n                response = _context6.sent;\n\n                if (response.ok) {\n                  _context6.next = 6;\n                  break;\n                }\n\n                throw new Error('Failed to PUT channel');\n\n              case 6:\n                if (this.sseClientInitialized) {\n                  _context6.next = 9;\n                  break;\n                }\n\n                _context6.next = 9;\n                return this.eventSource();\n\n              case 9:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function sendJSONtoChannel() {\n        return _sendJSONtoChannel.apply(this, arguments);\n      }\n\n      return sendJSONtoChannel;\n    }()\n    /**\r\n     * Creates a subscription, waits for a fact and then unsubscribes\r\n     *\r\n     * @param app Name of gall agent to subscribe to\r\n     * @param path Path to subscribe to\r\n     * @param timeout Optional timeout before ending subscription\r\n     *\r\n     * @returns The first fact on the subcription\r\n     */\n\n  }, {\n    key: \"subscribeOnce\",\n    value: function () {\n      var _subscribeOnce = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(app, path, timeout) {\n        var _this3 = this;\n\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                return _context8.abrupt(\"return\", new Promise( /*#__PURE__*/function () {\n                  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(resolve, reject) {\n                    var done, id, quit, event, request;\n                    return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n                      while (1) {\n                        switch (_context7.prev = _context7.next) {\n                          case 0:\n                            done = false;\n                            id = null;\n\n                            quit = function quit() {\n                              if (!done) {\n                                reject('quit');\n                              }\n                            };\n\n                            event = function event(e) {\n                              if (!done) {\n                                resolve(e);\n\n                                _this3.unsubscribe(id);\n                              }\n                            };\n\n                            request = {\n                              app: app,\n                              path: path,\n                              event: event,\n                              err: reject,\n                              quit: quit\n                            };\n                            _context7.next = 7;\n                            return _this3.subscribe(request);\n\n                          case 7:\n                            id = _context7.sent;\n\n                            if (timeout) {\n                              setTimeout(function () {\n                                if (!done) {\n                                  done = true;\n                                  reject('timeout');\n\n                                  _this3.unsubscribe(id);\n                                }\n                              }, timeout);\n                            }\n\n                          case 9:\n                          case \"end\":\n                            return _context7.stop();\n                        }\n                      }\n                    }, _callee7);\n                  }));\n\n                  return function (_x8, _x9) {\n                    return _ref.apply(this, arguments);\n                  };\n                }()));\n\n              case 1:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8);\n      }));\n\n      function subscribeOnce(_x5, _x6, _x7) {\n        return _subscribeOnce.apply(this, arguments);\n      }\n\n      return subscribeOnce;\n    }()\n    /**\r\n     * Pokes a ship with data.\r\n     *\r\n     * @param app The app to poke\r\n     * @param mark The mark of the data being sent\r\n     * @param json The data to send\r\n     */\n\n  }, {\n    key: \"poke\",\n    value: function () {\n      var _poke = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9(params) {\n        var _this4 = this;\n\n        var _onSuccess$onError$sh, app, mark, json, ship, _onSuccess, _onError, message, _yield$Promise$all, _yield$Promise$all2, send, result;\n\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                _onSuccess$onError$sh = _objectSpread({\n                  onSuccess: function onSuccess() {},\n                  onError: function onError() {},\n                  ship: this.ship\n                }, params), app = _onSuccess$onError$sh.app, mark = _onSuccess$onError$sh.mark, json = _onSuccess$onError$sh.json, ship = _onSuccess$onError$sh.ship, _onSuccess = _onSuccess$onError$sh.onSuccess, _onError = _onSuccess$onError$sh.onError;\n                message = {\n                  id: this.getEventId(),\n                  action: 'poke',\n                  ship: ship,\n                  app: app,\n                  mark: mark,\n                  json: json\n                };\n                _context9.next = 4;\n                return Promise.all([this.sendJSONtoChannel(message), new Promise(function (resolve, reject) {\n                  _this4.outstandingPokes.set(message.id, {\n                    onSuccess: function onSuccess() {\n                      _onSuccess();\n\n                      resolve(message.id);\n                    },\n                    onError: function onError(event) {\n                      _onError(event);\n\n                      reject(event.err);\n                    }\n                  });\n                })]);\n\n              case 4:\n                _yield$Promise$all = _context9.sent;\n                _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);\n                send = _yield$Promise$all2[0];\n                result = _yield$Promise$all2[1];\n                return _context9.abrupt(\"return\", result);\n\n              case 9:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function poke(_x10) {\n        return _poke.apply(this, arguments);\n      }\n\n      return poke;\n    }()\n    /**\r\n     * Subscribes to a path on an app on a ship.\r\n     *\r\n     *\r\n     * @param app The app to subsribe to\r\n     * @param path The path to which to subscribe\r\n     * @param handlers Handlers to deal with various events of the subscription\r\n     */\n\n  }, {\n    key: \"subscribe\",\n    value: function () {\n      var _subscribe = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10(params) {\n        var _err$event$quit$ship$, app, path, ship, err, event, quit, message;\n\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                _err$event$quit$ship$ = _objectSpread({\n                  err: function err() {},\n                  event: function event() {},\n                  quit: function quit() {},\n                  ship: this.ship\n                }, params), app = _err$event$quit$ship$.app, path = _err$event$quit$ship$.path, ship = _err$event$quit$ship$.ship, err = _err$event$quit$ship$.err, event = _err$event$quit$ship$.event, quit = _err$event$quit$ship$.quit;\n                message = {\n                  id: this.getEventId(),\n                  action: 'subscribe',\n                  ship: ship,\n                  app: app,\n                  path: path\n                };\n                this.outstandingSubscriptions.set(message.id, {\n                  app: app,\n                  path: path,\n                  err: err,\n                  event: event,\n                  quit: quit\n                });\n                _context10.next = 5;\n                return this.sendJSONtoChannel(message);\n\n              case 5:\n                return _context10.abrupt(\"return\", message.id);\n\n              case 6:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      function subscribe(_x11) {\n        return _subscribe.apply(this, arguments);\n      }\n\n      return subscribe;\n    }()\n    /**\r\n     * Unsubscribes to a given subscription.\r\n     *\r\n     * @param subscription\r\n     */\n\n  }, {\n    key: \"unsubscribe\",\n    value: function () {\n      var _unsubscribe = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11(subscription) {\n        var _this5 = this;\n\n        return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                return _context11.abrupt(\"return\", this.sendJSONtoChannel({\n                  id: this.getEventId(),\n                  action: 'unsubscribe',\n                  subscription: subscription\n                }).then(function () {\n                  _this5.outstandingSubscriptions.delete(subscription);\n                }));\n\n              case 1:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n\n      function unsubscribe(_x12) {\n        return _unsubscribe.apply(this, arguments);\n      }\n\n      return unsubscribe;\n    }()\n    /**\r\n     * Deletes the connection to a channel.\r\n     */\n\n  }, {\n    key: \"delete\",\n    value: function _delete() {\n      if (isBrowser_1) {\n        navigator.sendBeacon(this.channelUrl, JSON.stringify([{\n          action: 'delete'\n        }]));\n      }\n    }\n    /**\r\n     * Scry into an gall agent at a path\r\n     *\r\n     * @typeParam T - Type of the scry result\r\n     *\r\n     * @remarks\r\n     *\r\n     * Equivalent to\r\n     * ```hoon\r\n     * .^(T %gx /(scot %p our)/[app]/(scot %da now)/[path]/json)\r\n     * ```\r\n     * The returned cage must have a conversion to JSON for the scry to succeed\r\n     *\r\n     * @param params The scry request\r\n     * @returns The scry result\r\n     */\n\n  }, {\n    key: \"scry\",\n    value: function () {\n      var _scry = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee12(params) {\n        var app, path, response;\n        return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                app = params.app, path = params.path;\n                _context12.next = 3;\n                return fetch(\"\".concat(this.url, \"/~/scry/\").concat(app).concat(path, \".json\"), this.fetchOptions);\n\n              case 3:\n                response = _context12.sent;\n                _context12.next = 6;\n                return response.json();\n\n              case 6:\n                return _context12.abrupt(\"return\", _context12.sent);\n\n              case 7:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this);\n      }));\n\n      function scry(_x13) {\n        return _scry.apply(this, arguments);\n      }\n\n      return scry;\n    }()\n    /**\r\n     * Run a thread\r\n     *\r\n     *\r\n     * @param inputMark   The mark of the data being sent\r\n     * @param outputMark  The mark of the data being returned\r\n     * @param threadName  The thread to run\r\n     * @param body        The data to send to the thread\r\n     * @returns  The return value of the thread\r\n     */\n\n  }, {\n    key: \"thread\",\n    value: function () {\n      var _thread = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee13(params) {\n        var inputMark, outputMark, threadName, body, _params$desk, desk, res;\n\n        return _regeneratorRuntime.wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                inputMark = params.inputMark, outputMark = params.outputMark, threadName = params.threadName, body = params.body, _params$desk = params.desk, desk = _params$desk === void 0 ? this.desk : _params$desk;\n\n                if (desk) {\n                  _context13.next = 3;\n                  break;\n                }\n\n                throw new Error('Must supply desk to run thread from');\n\n              case 3:\n                _context13.next = 5;\n                return fetch(\"\".concat(this.url, \"/spider/\").concat(desk, \"/\").concat(inputMark, \"/\").concat(threadName, \"/\").concat(outputMark, \".json\"), _objectSpread(_objectSpread({}, this.fetchOptions), {}, {\n                  method: 'POST',\n                  body: JSON.stringify(body)\n                }));\n\n              case 5:\n                res = _context13.sent;\n                return _context13.abrupt(\"return\", res.json());\n\n              case 7:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this);\n      }));\n\n      function thread(_x14) {\n        return _thread.apply(this, arguments);\n      }\n\n      return thread;\n    }()\n    /**\r\n     * Utility function to connect to a ship that has its *.arvo.network domain configured.\r\n     *\r\n     * @param name Name of the ship e.g. zod\r\n     * @param code Code to log in\r\n     */\n\n  }], [{\n    key: \"authenticate\",\n    value: function () {\n      var _authenticate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee14(_ref2) {\n        var ship, url, code, _ref2$verbose, verbose, airlock;\n\n        return _regeneratorRuntime.wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                ship = _ref2.ship, url = _ref2.url, code = _ref2.code, _ref2$verbose = _ref2.verbose, verbose = _ref2$verbose === void 0 ? false : _ref2$verbose;\n                airlock = new Urbit(\"http://\".concat(url), code);\n                airlock.verbose = verbose;\n                airlock.ship = ship;\n                _context14.next = 6;\n                return airlock.connect();\n\n              case 6:\n                _context14.next = 8;\n                return airlock.poke({\n                  app: 'hood',\n                  mark: 'helm-hi',\n                  json: 'opening airlock'\n                });\n\n              case 8:\n                _context14.next = 10;\n                return airlock.eventSource();\n\n              case 10:\n                return _context14.abrupt(\"return\", airlock);\n\n              case 11:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14);\n      }));\n\n      function authenticate(_x15) {\n        return _authenticate.apply(this, arguments);\n      }\n\n      return authenticate;\n    }()\n  }, {\n    key: \"onArvoNetwork\",\n    value: function () {\n      var _onArvoNetwork = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee15(ship, code) {\n        var url;\n        return _regeneratorRuntime.wrap(function _callee15$(_context15) {\n          while (1) {\n            switch (_context15.prev = _context15.next) {\n              case 0:\n                url = \"https://\".concat(ship, \".arvo.network\");\n                _context15.next = 3;\n                return Urbit.authenticate({\n                  ship: ship,\n                  url: url,\n                  code: code\n                });\n\n              case 3:\n                return _context15.abrupt(\"return\", _context15.sent);\n\n              case 4:\n              case \"end\":\n                return _context15.stop();\n            }\n          }\n        }, _callee15);\n      }));\n\n      function onArvoNetwork(_x16, _x17) {\n        return _onArvoNetwork.apply(this, arguments);\n      }\n\n      return onArvoNetwork;\n    }()\n  }]);\n\n  return Urbit;\n}();\n\nexport { FatalError, ResumableError, Urbit, Urbit as default };","map":{"version":3,"mappings":"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","names":["ResumableError","Error","FatalError","Object","defineProperty","lib","value","_typeof","Symbol","iterator","obj","constructor","prototype","isBrowser","window","document","isWebWorker","self","name","isNode","process","versions","node","isJsDom","navigator","userAgent","includes","getBytes","stream","onChunk","reader","getReader","read","result","done","getLines","onLine","buffer","position","fieldLength","discardTrailingNewline","arr","undefined","concat","bufLength","length","lineStart","lineEnd","subarray","getMessages","onId","onRetry","onMessage","message","newMessage","decoder","TextDecoder","line","field","decode","valueOffset","data","event","id","retry","parseInt","isNaN","a","b","res","Uint8Array","set","__rest","this","s","e","t","p","hasOwnProperty","call","indexOf","getOwnPropertySymbols","i","propertyIsEnumerable","EventStreamContentType","DefaultRetryInterval","LastEventId","fetchEventSource","input","_a","inputSignal","signal","inputHeaders","headers","inputOnOpen","onopen","onmessage","onclose","onerror","openWhenHidden","inputFetch","fetch","rest","Promise","resolve","reject","assign","accept","curRequestController","onVisibilityChange","abort","hidden","create","addEventListener","retryInterval","retryTimer","dispose","removeEventListener","clearTimeout","defaultOnOpen","AbortController","response","body","aborted","interval","setTimeout","innerErr","contentType","get","startsWith","hexString","len","maxlen","min","Math","pow","max","n","floor","random","r","toString","Urbit","url","code","desk","Date","now","Map","delete","uid","Cookie","cookie","credentials","verbose","console","log","method","then","ship","RegExp","exec","sseClientInitialized","lastEventId","poke","app","mark","json","channelUrl","fetchOptions","ok","errorCount","onOpen","err","lastAcknowledgedEventId","ack","JSON","parse","outstandingPokes","has","funcs","onSuccess","error","onError","outstandingSubscriptions","quit","keys","warn","Number","eventId","action","sendJSONtoChannel","stringify","eventSource","path","timeout","unsubscribe","request","subscribe","params","getEventId","all","send","subscription","sendBeacon","inputMark","outputMark","threadName","airlock","connect","authenticate"],"sources":["/home/mike/proj/frontend/ui/node_modules/@urbit/http-api/src/types.ts","/home/mike/proj/frontend/ui/node_modules/@urbit/http-api/node_modules/browser-or-node/lib/index.js","/home/mike/proj/frontend/ui/node_modules/@urbit/http-api/node_modules/@microsoft/fetch-event-source/lib/esm/parse.js","/home/mike/proj/frontend/ui/node_modules/@urbit/http-api/node_modules/@microsoft/fetch-event-source/lib/esm/fetch.js","/home/mike/proj/frontend/ui/node_modules/@urbit/http-api/src/utils.ts","/home/mike/proj/frontend/ui/node_modules/@urbit/http-api/src/Urbit.ts"],"sourcesContent":["/**\n * An urbit style path, rendered as a Javascript string\n * @example\n * `\"/updates\"`\n */\nexport type Path = string;\n\n/**\n * @p including leading sig, rendered as a string\n *\n * @example\n * ```typescript\n * \"~sampel-palnet\"\n * ```\n *\n */\nexport type Patp = string;\n\n/**\n * @p not including leading sig, rendered as a string\n *\n * @example\n * ```typescript\n * \"sampel-palnet\"\n * ```\n *\n */\nexport type PatpNoSig = string;\n\n/**\n * The name of a clay mark, as a string\n *\n * @example\n * ```typescript\n * \"graph-update\"\n * ```\n */\nexport type Mark = string;\n\n/**\n * The name of a gall agent, as a string\n *\n * @example\n *\n * ```typescript\n * \"graph-store\"\n * ```\n */\nexport type GallAgent = string;\n\n/**\n * Description of an outgoing poke\n *\n * @typeParam Action - Typescript type of the data being poked\n */\nexport interface Poke<Action> {\n  /**\n   * Ship to poke. If left empty, the api lib will populate it with the ship that it is connected to.\n   *\n   * @remarks\n   *\n   * This should always be the ship that you are connected to\n   *\n   */\n  ship?: PatpNoSig;\n  /**\n   */\n  app: GallAgent;\n  /**\n   * Mark of the cage to be poked\n   *\n   */\n  mark: Mark;\n  /**\n   * Vase of the cage of to be poked, as JSON\n   */\n  json: Action;\n}\n\n/**\n * Description of a scry request\n */\nexport interface Scry {\n  /** {@inheritDoc GallAgent} */\n  app: GallAgent;\n  /** {@inheritDoc Path} */\n  path: Path;\n}\n\n/**\n * Description of a thread request\n *\n * @typeParam Action - Typescript type of the data being poked\n */\nexport interface Thread<Action> {\n  /**\n   * The mark of the input vase\n   */\n  inputMark: Mark;\n  /**\n   * The mark of the output vase\n   */\n  outputMark: Mark;\n  /**\n   * Name of the thread\n   *\n   * @example\n   * ```typescript\n   * \"graph-add-nodes\"\n   * ```\n   */\n  threadName: string;\n  /**\n   * Desk of thread\n   */\n  desk?: string;\n  /**\n   * Data of the input vase\n   */\n  body: Action;\n}\n\nexport type Action = 'poke' | 'subscribe' | 'ack' | 'unsubscribe' | 'delete';\n\nexport interface PokeHandlers {\n  onSuccess?: () => void;\n  onError?: (e: any) => void;\n}\n\nexport type PokeInterface<T> = PokeHandlers & Poke<T>;\n\nexport interface AuthenticationInterface {\n  ship: string;\n  url: string;\n  code: string;\n  verbose?: boolean;\n}\n\n/**\n * Subscription event handlers\n *\n */\nexport interface SubscriptionInterface {\n  /**\n   * Handle negative %watch-ack\n   */\n  err?(error: any, id: string): void;\n  /**\n   * Handle %fact\n   */\n  event?(data: any): void;\n  /**\n   * Handle %kick\n   */\n  quit?(data: any): void;\n}\n\nexport type OnceSubscriptionErr = 'quit' | 'nack' | 'timeout';\n\nexport interface SubscriptionRequestInterface extends SubscriptionInterface {\n  /**\n   * The app to subscribe to\n   * @example\n   * `\"graph-store\"`\n   */\n  app: GallAgent;\n  /**\n   * The path to which to subscribe\n   * @example\n   * `\"/keys\"`\n   */\n  path: Path;\n}\n\nexport interface headers {\n  'Content-Type': string;\n  Cookie?: string;\n}\n\nexport interface CustomEventHandler {\n  (data: any, response: string): void;\n}\n\nexport interface SSEOptions {\n  headers?: {\n    Cookie?: string;\n  };\n  withCredentials?: boolean;\n}\n\nexport interface Message extends Record<string, any> {\n  action: Action;\n  id?: number;\n}\n\nexport class ResumableError extends Error {}\n\nexport class FatalError extends Error {}\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/* global window self */\n\nvar isBrowser = typeof window !== 'undefined' && typeof window.document !== 'undefined';\n\n/* eslint-disable no-restricted-globals */\nvar isWebWorker = (typeof self === 'undefined' ? 'undefined' : _typeof(self)) === 'object' && self.constructor && self.constructor.name === 'DedicatedWorkerGlobalScope';\n/* eslint-enable no-restricted-globals */\n\nvar isNode = typeof process !== 'undefined' && process.versions != null && process.versions.node != null;\n\n/**\n * @see https://github.com/jsdom/jsdom/releases/tag/12.0.0\n * @see https://github.com/jsdom/jsdom/issues/1537\n */\n/* eslint-disable no-undef */\nvar isJsDom = function isJsDom() {\n  return typeof window !== 'undefined' && window.name === 'nodejs' || navigator.userAgent.includes('Node.js') || navigator.userAgent.includes('jsdom');\n};\n\nexports.isBrowser = isBrowser;\nexports.isWebWorker = isWebWorker;\nexports.isNode = isNode;\nexports.isJsDom = isJsDom;","export async function getBytes(stream, onChunk) {\r\n    const reader = stream.getReader();\r\n    let result;\r\n    while (!(result = await reader.read()).done) {\r\n        onChunk(result.value);\r\n    }\r\n}\r\nexport function getLines(onLine) {\r\n    let buffer;\r\n    let position;\r\n    let fieldLength;\r\n    let discardTrailingNewline = false;\r\n    return function onChunk(arr) {\r\n        if (buffer === undefined) {\r\n            buffer = arr;\r\n            position = 0;\r\n            fieldLength = -1;\r\n        }\r\n        else {\r\n            buffer = concat(buffer, arr);\r\n        }\r\n        const bufLength = buffer.length;\r\n        let lineStart = 0;\r\n        while (position < bufLength) {\r\n            if (discardTrailingNewline) {\r\n                if (buffer[position] === 10) {\r\n                    lineStart = ++position;\r\n                }\r\n                discardTrailingNewline = false;\r\n            }\r\n            let lineEnd = -1;\r\n            for (; position < bufLength && lineEnd === -1; ++position) {\r\n                switch (buffer[position]) {\r\n                    case 58:\r\n                        if (fieldLength === -1) {\r\n                            fieldLength = position - lineStart;\r\n                        }\r\n                        break;\r\n                    case 13:\r\n                        discardTrailingNewline = true;\r\n                    case 10:\r\n                        lineEnd = position;\r\n                        break;\r\n                }\r\n            }\r\n            if (lineEnd === -1) {\r\n                break;\r\n            }\r\n            onLine(buffer.subarray(lineStart, lineEnd), fieldLength);\r\n            lineStart = position;\r\n            fieldLength = -1;\r\n        }\r\n        if (lineStart === bufLength) {\r\n            buffer = undefined;\r\n        }\r\n        else if (lineStart !== 0) {\r\n            buffer = buffer.subarray(lineStart);\r\n            position -= lineStart;\r\n        }\r\n    };\r\n}\r\nexport function getMessages(onId, onRetry, onMessage) {\r\n    let message = newMessage();\r\n    const decoder = new TextDecoder();\r\n    return function onLine(line, fieldLength) {\r\n        if (line.length === 0) {\r\n            onMessage === null || onMessage === void 0 ? void 0 : onMessage(message);\r\n            message = newMessage();\r\n        }\r\n        else if (fieldLength > 0) {\r\n            const field = decoder.decode(line.subarray(0, fieldLength));\r\n            const valueOffset = fieldLength + (line[fieldLength + 1] === 32 ? 2 : 1);\r\n            const value = decoder.decode(line.subarray(valueOffset));\r\n            switch (field) {\r\n                case 'data':\r\n                    message.data = message.data\r\n                        ? message.data + '\\n' + value\r\n                        : value;\r\n                    break;\r\n                case 'event':\r\n                    message.event = value;\r\n                    break;\r\n                case 'id':\r\n                    onId(message.id = value);\r\n                    break;\r\n                case 'retry':\r\n                    const retry = parseInt(value, 10);\r\n                    if (!isNaN(retry)) {\r\n                        onRetry(message.retry = retry);\r\n                    }\r\n                    break;\r\n            }\r\n        }\r\n    };\r\n}\r\nfunction concat(a, b) {\r\n    const res = new Uint8Array(a.length + b.length);\r\n    res.set(a);\r\n    res.set(b, a.length);\r\n    return res;\r\n}\r\nfunction newMessage() {\r\n    return {\r\n        data: '',\r\n        event: '',\r\n        id: '',\r\n        retry: undefined,\r\n    };\r\n}\r\n//# sourceMappingURL=parse.js.map","var __rest = (this && this.__rest) || function (s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n};\r\nimport { getBytes, getLines, getMessages } from './parse';\r\nexport const EventStreamContentType = 'text/event-stream';\r\nconst DefaultRetryInterval = 1000;\r\nconst LastEventId = 'last-event-id';\r\nexport function fetchEventSource(input, _a) {\r\n    var { signal: inputSignal, headers: inputHeaders, onopen: inputOnOpen, onmessage, onclose, onerror, openWhenHidden, fetch: inputFetch } = _a, rest = __rest(_a, [\"signal\", \"headers\", \"onopen\", \"onmessage\", \"onclose\", \"onerror\", \"openWhenHidden\", \"fetch\"]);\r\n    return new Promise((resolve, reject) => {\r\n        const headers = Object.assign({}, inputHeaders);\r\n        if (!headers.accept) {\r\n            headers.accept = EventStreamContentType;\r\n        }\r\n        let curRequestController;\r\n        function onVisibilityChange() {\r\n            curRequestController.abort();\r\n            if (!document.hidden) {\r\n                create();\r\n            }\r\n        }\r\n        if (!openWhenHidden) {\r\n            document.addEventListener('visibilitychange', onVisibilityChange);\r\n        }\r\n        let retryInterval = DefaultRetryInterval;\r\n        let retryTimer = 0;\r\n        function dispose() {\r\n            document.removeEventListener('visibilitychange', onVisibilityChange);\r\n            window.clearTimeout(retryTimer);\r\n            curRequestController.abort();\r\n        }\r\n        inputSignal === null || inputSignal === void 0 ? void 0 : inputSignal.addEventListener('abort', () => {\r\n            dispose();\r\n            resolve();\r\n        });\r\n        const fetch = inputFetch !== null && inputFetch !== void 0 ? inputFetch : window.fetch;\r\n        const onopen = inputOnOpen !== null && inputOnOpen !== void 0 ? inputOnOpen : defaultOnOpen;\r\n        async function create() {\r\n            var _a;\r\n            curRequestController = new AbortController();\r\n            try {\r\n                const response = await fetch(input, Object.assign(Object.assign({}, rest), { headers, signal: curRequestController.signal }));\r\n                await onopen(response);\r\n                await getBytes(response.body, getLines(getMessages(id => {\r\n                    if (id) {\r\n                        headers[LastEventId] = id;\r\n                    }\r\n                    else {\r\n                        delete headers[LastEventId];\r\n                    }\r\n                }, retry => {\r\n                    retryInterval = retry;\r\n                }, onmessage)));\r\n                onclose === null || onclose === void 0 ? void 0 : onclose();\r\n                dispose();\r\n                resolve();\r\n            }\r\n            catch (err) {\r\n                if (!curRequestController.signal.aborted) {\r\n                    try {\r\n                        const interval = (_a = onerror === null || onerror === void 0 ? void 0 : onerror(err)) !== null && _a !== void 0 ? _a : retryInterval;\r\n                        window.clearTimeout(retryTimer);\r\n                        retryTimer = window.setTimeout(create, interval);\r\n                    }\r\n                    catch (innerErr) {\r\n                        dispose();\r\n                        reject(innerErr);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        create();\r\n    });\r\n}\r\nfunction defaultOnOpen(response) {\r\n    const contentType = response.headers.get('content-type');\r\n    if (!(contentType === null || contentType === void 0 ? void 0 : contentType.startsWith(EventStreamContentType))) {\r\n        throw new Error(`Expected content-type to be ${EventStreamContentType}, Actual: ${contentType}`);\r\n    }\r\n}\r\n//# sourceMappingURL=fetch.js.map","export function camelize(str: string) {\n  return str\n    .replace(/\\s(.)/g, function ($1: string) {\n      return $1.toUpperCase();\n    })\n    .replace(/\\s/g, '')\n    .replace(/^(.)/, function ($1: string) {\n      return $1.toLowerCase();\n    });\n}\n\nexport function uncamelize(str: string, separator = '-') {\n  // Replace all capital letters by separator followed by lowercase one\n  var str = str.replace(/[A-Z]/g, function (letter: string) {\n    return separator + letter.toLowerCase();\n  });\n  return str.replace(new RegExp('^' + separator), '');\n}\n\n/**\n * Returns a hex string of given length.\n *\n * Poached from StackOverflow.\n *\n * @param len Length of hex string to return.\n */\nexport function hexString(len: number): string {\n  const maxlen = 8;\n  const min = Math.pow(16, Math.min(len, maxlen) - 1);\n  const max = Math.pow(16, Math.min(len, maxlen)) - 1;\n  const n = Math.floor(Math.random() * (max - min + 1)) + min;\n  let r = n.toString(16);\n  while (r.length < len) {\n    r = r + hexString(len - maxlen);\n  }\n  return r;\n}\n\n/**\n * Generates a random UID.\n *\n * Copied from https://github.com/urbit/urbit/blob/137e4428f617c13f28ed31e520eff98d251ed3e9/pkg/interface/src/lib/util.js#L3\n */\nexport function uid(): string {\n  let str = '0v';\n  str += Math.ceil(Math.random() * 8) + '.';\n  for (let i = 0; i < 5; i++) {\n    let _str = Math.ceil(Math.random() * 10000000).toString(32);\n    _str = ('00000' + _str).substr(-5, 5);\n    str += _str + '.';\n  }\n  return str.slice(0, -1);\n}\n","import { isBrowser, isNode } from 'browser-or-node';\nimport {\n  fetchEventSource,\n  EventSourceMessage,\n} from '@microsoft/fetch-event-source';\n\nimport {\n  Scry,\n  Thread,\n  AuthenticationInterface,\n  PokeInterface,\n  SubscriptionRequestInterface,\n  headers,\n  SSEOptions,\n  PokeHandlers,\n  Message,\n} from './types';\nimport { hexString } from './utils';\n\n/**\n * A class for interacting with an urbit ship, given its URL and code\n */\nexport class Urbit {\n  /**\n   * UID will be used for the channel: The current unix time plus a random hex string\n   */\n  private uid: string = `${Math.floor(Date.now() / 1000)}-${hexString(6)}`;\n\n  /**\n   * Last Event ID is an auto-updated index of which events have been sent over this channel\n   */\n  private lastEventId: number = 0;\n\n  private lastAcknowledgedEventId: number = 0;\n\n  /**\n   * SSE Client is null for now; we don't want to start polling until it the channel exists\n   */\n  private sseClientInitialized: boolean = false;\n\n  /**\n   * Cookie gets set when we log in.\n   */\n  cookie?: string | undefined;\n\n  /**\n   * A registry of requestId to successFunc/failureFunc\n   *\n   * These functions are registered during a +poke and are executed\n   * in the onServerEvent()/onServerError() callbacks. Only one of\n   * the functions will be called, and the outstanding poke will be\n   * removed after calling the success or failure function.\n   */\n\n  private outstandingPokes: Map<number, PokeHandlers> = new Map();\n\n  /**\n   * A registry of requestId to subscription functions.\n   *\n   * These functions are registered during a +subscribe and are\n   * executed in the onServerEvent()/onServerError() callbacks. The\n   * event function will be called whenever a new piece of data on this\n   * subscription is available, which may be 0, 1, or many times. The\n   * disconnect function may be called exactly once.\n   */\n  private outstandingSubscriptions: Map<number, SubscriptionRequestInterface> =\n    new Map();\n\n  /**\n   * Our abort controller, used to close the connection\n   */\n  private abort = new AbortController();\n\n  /**\n   * Ship can be set, in which case we can do some magic stuff like send chats\n   */\n  ship?: string | null;\n\n  /**\n   * If verbose, logs output eagerly.\n   */\n  verbose?: boolean;\n\n  /**\n   * number of consecutive errors in connecting to the eventsource\n   */\n  private errorCount = 0;\n\n  onError?: (error: any) => void = null;\n\n  onRetry?: () => void = null;\n\n  onOpen?: () => void = null;\n\n  /** This is basic interpolation to get the channel URL of an instantiated Urbit connection. */\n  private get channelUrl(): string {\n    return `${this.url}/~/channel/${this.uid}`;\n  }\n\n  private get fetchOptions(): any {\n    const headers: headers = {\n      'Content-Type': 'application/json',\n    };\n    if (!isBrowser) {\n      headers.Cookie = this.cookie;\n    }\n    return {\n      credentials: 'include',\n      accept: '*',\n      headers,\n      signal: this.abort.signal,\n    };\n  }\n\n  /**\n   * Constructs a new Urbit connection.\n   *\n   * @param url  The URL (with protocol and port) of the ship to be accessed. If\n   * the airlock is running in a webpage served by the ship, this should just\n   * be the empty string.\n   * @param code The access code for the ship at that address\n   */\n  constructor(public url: string, public code?: string, public desk?: string) {\n    if (isBrowser) {\n      window.addEventListener('beforeunload', this.delete);\n    }\n    return this;\n  }\n\n  /**\n   * All-in-one hook-me-up.\n   *\n   * Given a ship, url, and code, this returns an airlock connection\n   * that is ready to go. It `|hi`s itself to create the channel,\n   * then opens the channel via EventSource.\n   *\n   */\n  static async authenticate({\n    ship,\n    url,\n    code,\n    verbose = false,\n  }: AuthenticationInterface) {\n    const airlock = new Urbit(`http://${url}`, code);\n    airlock.verbose = verbose;\n    airlock.ship = ship;\n    await airlock.connect();\n    await airlock.poke({\n      app: 'hood',\n      mark: 'helm-hi',\n      json: 'opening airlock',\n    });\n    await airlock.eventSource();\n    return airlock;\n  }\n\n  /**\n   * Connects to the Urbit ship. Nothing can be done until this is called.\n   * That's why we roll it into this.authenticate\n   */\n  async connect(): Promise<void> {\n    if (this.verbose) {\n      console.log(\n        `password=${this.code} `,\n        isBrowser\n          ? 'Connecting in browser context at ' + `${this.url}/~/login`\n          : 'Connecting from node context'\n      );\n    }\n    return fetch(`${this.url}/~/login`, {\n      method: 'post',\n      body: `password=${this.code}`,\n      credentials: 'include',\n    }).then((response) => {\n      if (this.verbose) {\n        console.log('Received authentication response', response);\n      }\n      const cookie = response.headers.get('set-cookie');\n      if (!this.ship) {\n        this.ship = new RegExp(/urbauth-~([\\w-]+)/).exec(cookie)[1];\n      }\n      if (!isBrowser) {\n        this.cookie = cookie;\n      }\n    });\n  }\n\n  /**\n   * Initializes the SSE pipe for the appropriate channel.\n   */\n  async eventSource(): Promise<void> {\n    if (this.sseClientInitialized) {\n      return Promise.resolve();\n    }\n    if (this.lastEventId === 0) {\n      // Can't receive events until the channel is open,\n      // so poke and open then\n      await this.poke({\n        app: 'hood',\n        mark: 'helm-hi',\n        json: 'Opening API channel',\n      });\n      return;\n    }\n    this.sseClientInitialized = true;\n    return new Promise((resolve, reject) => {\n      const sseOptions: SSEOptions = {\n        headers: {},\n      };\n      if (isBrowser) {\n        sseOptions.withCredentials = true;\n      } else if (isNode) {\n        sseOptions.headers.Cookie = this.cookie;\n      }\n      fetchEventSource(this.channelUrl, {\n        ...this.fetchOptions,\n        openWhenHidden: true,\n        onopen: async (response) => {\n          if (this.verbose) {\n            console.log('Opened eventsource', response);\n          }\n          if (response.ok) {\n            this.errorCount = 0;\n            this.onOpen && this.onOpen();\n            resolve();\n            return; // everything's good\n          } else {\n            const err = new Error('failed to open eventsource');\n            reject(err);\n          }\n        },\n        onmessage: (event: EventSourceMessage) => {\n          if (this.verbose) {\n            console.log('Received SSE: ', event);\n          }\n          if (!event.id) return;\n          this.lastEventId = parseInt(event.id, 10);\n          if (this.lastEventId - this.lastAcknowledgedEventId > 20) {\n            this.ack(this.lastEventId);\n          }\n\n          if (event.data && JSON.parse(event.data)) {\n            const data: any = JSON.parse(event.data);\n\n            if (\n              data.response === 'poke' &&\n              this.outstandingPokes.has(data.id)\n            ) {\n              const funcs = this.outstandingPokes.get(data.id);\n              if (data.hasOwnProperty('ok')) {\n                funcs.onSuccess();\n              } else if (data.hasOwnProperty('err')) {\n                console.error(data.err);\n                funcs.onError(data.err);\n              } else {\n                console.error('Invalid poke response', data);\n              }\n              this.outstandingPokes.delete(data.id);\n            } else if (\n              data.response === 'subscribe' &&\n              this.outstandingSubscriptions.has(data.id)\n            ) {\n              const funcs = this.outstandingSubscriptions.get(data.id);\n              if (data.hasOwnProperty('err')) {\n                console.error(data.err);\n                funcs.err(data.err, data.id);\n                this.outstandingSubscriptions.delete(data.id);\n              }\n            } else if (\n              data.response === 'diff' &&\n              this.outstandingSubscriptions.has(data.id)\n            ) {\n              const funcs = this.outstandingSubscriptions.get(data.id);\n              try {\n                funcs.event(data.json);\n              } catch (e) {\n                console.error('Failed to call subscription event callback', e);\n              }\n            } else if (\n              data.response === 'quit' &&\n              this.outstandingSubscriptions.has(data.id)\n            ) {\n              const funcs = this.outstandingSubscriptions.get(data.id);\n              funcs.quit(data);\n              this.outstandingSubscriptions.delete(data.id);\n            } else {\n              console.log([...this.outstandingSubscriptions.keys()]);\n              console.log('Unrecognized response', data);\n            }\n          }\n        },\n        onerror: (error) => {\n          console.warn(error);\n          if (this.errorCount++ < 4) {\n            this.onRetry && this.onRetry();\n            return Math.pow(2, this.errorCount - 1) * 750;\n          }\n          this.onError && this.onError(error);\n          throw error;\n        },\n        onclose: () => {\n          console.log('e');\n          throw new Error('Ship unexpectedly closed the connection');\n        },\n      });\n    });\n  }\n\n  /**\n   * Reset airlock, abandoning current subscriptions and wiping state\n   *\n   */\n  reset() {\n    this.delete();\n    this.abort.abort();\n    this.abort = new AbortController();\n    this.uid = `${Math.floor(Date.now() / 1000)}-${hexString(6)}`;\n    this.lastEventId = 0;\n    this.lastAcknowledgedEventId = 0;\n    this.outstandingSubscriptions = new Map();\n    this.outstandingPokes = new Map();\n    this.sseClientInitialized = false;\n  }\n\n  /**\n   * Autoincrements the next event ID for the appropriate channel.\n   */\n  private getEventId(): number {\n    this.lastEventId = Number(this.lastEventId) + 1;\n    return this.lastEventId;\n  }\n\n  /**\n   * Acknowledges an event.\n   *\n   * @param eventId The event to acknowledge.\n   */\n  private async ack(eventId: number): Promise<number | void> {\n    this.lastAcknowledgedEventId = eventId;\n    const message: Message = {\n      action: 'ack',\n      'event-id': eventId,\n    };\n    await this.sendJSONtoChannel(message);\n    return eventId;\n  }\n\n  private async sendJSONtoChannel(...json: Message[]): Promise<void> {\n    const response = await fetch(this.channelUrl, {\n      ...this.fetchOptions,\n      method: 'PUT',\n      body: JSON.stringify(json),\n    });\n    if (!response.ok) {\n      throw new Error('Failed to PUT channel');\n    }\n    if (!this.sseClientInitialized) {\n      await this.eventSource();\n    }\n  }\n\n  /**\n   * Creates a subscription, waits for a fact and then unsubscribes\n   *\n   * @param app Name of gall agent to subscribe to\n   * @param path Path to subscribe to\n   * @param timeout Optional timeout before ending subscription\n   *\n   * @returns The first fact on the subcription\n   */\n  async subscribeOnce<T = any>(app: string, path: string, timeout?: number) {\n    return new Promise<T>(async (resolve, reject) => {\n      let done = false;\n      let id: number | null = null;\n      const quit = () => {\n        if (!done) {\n          reject('quit');\n        }\n      };\n      const event = (e: T) => {\n        if (!done) {\n          resolve(e);\n          this.unsubscribe(id);\n        }\n      };\n      const request = { app, path, event, err: reject, quit };\n\n      id = await this.subscribe(request);\n\n      if (timeout) {\n        setTimeout(() => {\n          if (!done) {\n            done = true;\n            reject('timeout');\n            this.unsubscribe(id);\n          }\n        }, timeout);\n      }\n    });\n  }\n\n  /**\n   * Pokes a ship with data.\n   *\n   * @param app The app to poke\n   * @param mark The mark of the data being sent\n   * @param json The data to send\n   */\n  async poke<T>(params: PokeInterface<T>): Promise<number> {\n    const { app, mark, json, ship, onSuccess, onError } = {\n      onSuccess: () => {},\n      onError: () => {},\n      ship: this.ship,\n      ...params,\n    };\n    const message: Message = {\n      id: this.getEventId(),\n      action: 'poke',\n      ship,\n      app,\n      mark,\n      json,\n    };\n    const [send, result] = await Promise.all([\n      this.sendJSONtoChannel(message),\n      new Promise<number>((resolve, reject) => {\n        this.outstandingPokes.set(message.id, {\n          onSuccess: () => {\n            onSuccess();\n            resolve(message.id);\n          },\n          onError: (event) => {\n            onError(event);\n            reject(event.err);\n          },\n        });\n      }),\n    ]);\n    return result;\n  }\n\n  /**\n   * Subscribes to a path on an app on a ship.\n   *\n   *\n   * @param app The app to subsribe to\n   * @param path The path to which to subscribe\n   * @param handlers Handlers to deal with various events of the subscription\n   */\n  async subscribe(params: SubscriptionRequestInterface): Promise<number> {\n    const { app, path, ship, err, event, quit } = {\n      err: () => {},\n      event: () => {},\n      quit: () => {},\n      ship: this.ship,\n      ...params,\n    };\n\n    const message: Message = {\n      id: this.getEventId(),\n      action: 'subscribe',\n      ship,\n      app,\n      path,\n    };\n\n    this.outstandingSubscriptions.set(message.id, {\n      app,\n      path,\n      err,\n      event,\n      quit,\n    });\n\n    await this.sendJSONtoChannel(message);\n\n    return message.id;\n  }\n\n  /**\n   * Unsubscribes to a given subscription.\n   *\n   * @param subscription\n   */\n  async unsubscribe(subscription: number) {\n    return this.sendJSONtoChannel({\n      id: this.getEventId(),\n      action: 'unsubscribe',\n      subscription,\n    }).then(() => {\n      this.outstandingSubscriptions.delete(subscription);\n    });\n  }\n\n  /**\n   * Deletes the connection to a channel.\n   */\n  delete() {\n    if (isBrowser) {\n      navigator.sendBeacon(\n        this.channelUrl,\n        JSON.stringify([\n          {\n            action: 'delete',\n          },\n        ])\n      );\n    } else {\n      // TODO\n      // this.sendMessage('delete');\n    }\n  }\n\n  /**\n   * Scry into an gall agent at a path\n   *\n   * @typeParam T - Type of the scry result\n   *\n   * @remarks\n   *\n   * Equivalent to\n   * ```hoon\n   * .^(T %gx /(scot %p our)/[app]/(scot %da now)/[path]/json)\n   * ```\n   * The returned cage must have a conversion to JSON for the scry to succeed\n   *\n   * @param params The scry request\n   * @returns The scry result\n   */\n  async scry<T = any>(params: Scry): Promise<T> {\n    const { app, path } = params;\n    const response = await fetch(\n      `${this.url}/~/scry/${app}${path}.json`,\n      this.fetchOptions\n    );\n    return await response.json();\n  }\n\n  /**\n   * Run a thread\n   *\n   *\n   * @param inputMark   The mark of the data being sent\n   * @param outputMark  The mark of the data being returned\n   * @param threadName  The thread to run\n   * @param body        The data to send to the thread\n   * @returns  The return value of the thread\n   */\n  async thread<R, T = any>(params: Thread<T>): Promise<R> {\n    const {\n      inputMark,\n      outputMark,\n      threadName,\n      body,\n      desk = this.desk,\n    } = params;\n    if (!desk) {\n      throw new Error('Must supply desk to run thread from');\n    }\n    const res = await fetch(\n      `${this.url}/spider/${desk}/${inputMark}/${threadName}/${outputMark}.json`,\n      {\n        ...this.fetchOptions,\n        method: 'POST',\n        body: JSON.stringify(body),\n      }\n    );\n\n    return res.json();\n  }\n\n  /**\n   * Utility function to connect to a ship that has its *.arvo.network domain configured.\n   *\n   * @param name Name of the ship e.g. zod\n   * @param code Code to log in\n   */\n  static async onArvoNetwork(ship: string, code: string): Promise<Urbit> {\n    const url = `https://${ship}.arvo.network`;\n    return await Urbit.authenticate({ ship, url, code });\n  }\n}\n\nexport default Urbit;\n"]},"metadata":{},"sourceType":"module"}