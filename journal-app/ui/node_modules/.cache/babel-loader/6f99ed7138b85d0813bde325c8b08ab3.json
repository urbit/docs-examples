{"ast":null,"code":"const LocaleHelper = require('../LocaleHelper/LocaleHelper.js');\n\nconst defaultLocale = require('../data/defaultLocale.js');\n/**\n * Represents a parsable date format\n */\n\n\nclass Format {\n  /**\n   * Given a definition, create a parsable format\n   * @param {Object} definition  The format definition\n   * @property {String} template  A template for RegExp that can handle multiple languages\n   * @property {RegExp} matcher  An actual RegExp to match against\n   * @property {Array} units  If the template or RegExp match exact units, you can define the units\n   * @property {Function} handler  A flexible alternative to units; must return an object\n   * @property {Array} locales  A list of locales that this format should be restricted to\n   */\n  constructor(_ref) {\n    let {\n      template = null,\n      matcher = null,\n      units = null,\n      handler = null,\n      locales = null\n    } = _ref;\n\n    if (!Array.isArray(units) && typeof handler !== 'function') {\n      throw new Error('new Format must receive a \"units\" array or \"handler\" function');\n    }\n\n    if (typeof template !== 'string' && !(matcher instanceof RegExp)) {\n      throw new Error('new Format must receive a \"template\" string or \"matcher\" RegExp');\n    }\n    /**\n     * @type {String} template  A template for RegExp that can handle multiple languages\n     */\n\n\n    this.template = template;\n    /**\n     * @type {Array} units  If the template or RegExp match exact units, you can define the units\n     */\n\n    this.units = units;\n    /**\n     * @type {RegExp} matcher  An actual RegExp to match against\n     */\n\n    this.matcher = matcher;\n    /**\n     * @type {Function} handler  A flexible alternative to units; must return an object\n     */\n\n    this.handler = handler;\n    /**\n     * @type {String[]} locales  A list of locales that this format should be restricted to\n     */\n\n    this.locales = locales;\n    /**\n     * A cache of RegExp indexed by locale name\n     * @type {Object}\n     */\n\n    this.regexByLocale = {};\n  }\n  /**\n   * Build the RegExp from the template for a given locale\n   * @param {String} locale  The language locale such as en-US, pt-BR, zh, es, etc.\n   * @returns {RegExp}  A RegExp that matches when this format is recognized\n   */\n\n\n  getRegExp() {\n    let locale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultLocale;\n\n    if (this.template) {\n      if (!this.regexByLocale[locale]) {\n        this.regexByLocale[locale] = LocaleHelper.factory(locale).compile(this.template);\n      }\n\n      return this.regexByLocale[locale];\n    }\n\n    return this.matcher;\n  }\n  /**\n   * Run this format's RegExp against the given string\n   * @param {String} string  The date string\n   * @param {String} locale  The language locale such as en-US, pt-BR, zh, es, etc.\n   * @returns {Array|null}  Array of matches or null on non-match\n   */\n\n\n  getMatches(string) {\n    let locale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultLocale;\n    return string.match(this.getRegExp(locale));\n  }\n  /**\n   * Given matches against this RegExp, convert to object\n   * @param {String[]} matches  An array of matched parts\n   * @param {String} locale  The language locale such as en-US, pt-BR, zh, es, etc.\n   * @returns {Object}  Object which may contain year, month, day, hour, minute, second, millisecond, offset, invalid\n   */\n\n\n  toDateTime(matches) {\n    let locale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultLocale;\n    const locHelper = LocaleHelper.factory(locale);\n\n    if (this.units) {\n      return locHelper.getObject(this.units, matches);\n    }\n\n    const dt = this.handler(matches, locale);\n\n    if (!dt || dt.invalid) {\n      return dt;\n    }\n\n    return locHelper.castObject(dt);\n  }\n  /**\n   * Attempt to parse a string in this format\n   * @param {String} string  The date string\n   * @param {String} locale  The language locale such as en-US, pt-BR, zh, es, etc.\n   * @returns {Object|null}  Null if format can't handle this string, Object for result or error\n   */\n\n\n  attempt(string) {\n    let locale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultLocale;\n    string = String(string).trim();\n    const matches = this.getMatches(string, locale);\n\n    if (matches) {\n      const dt = this.toDateTime(matches, locale);\n\n      if (dt && !dt.invalid) {\n        return dt;\n      }\n    }\n\n    return null;\n  }\n  /**\n   * Return the current date (used to support unit testing)\n   * @returns {Date}\n   */\n\n\n  now() {\n    return new Date();\n  }\n\n}\n\nmodule.exports = Format;","map":{"version":3,"sources":["/home/mike/proj/frontend/ui/node_modules/any-date-parser/src/Format/Format.js"],"names":["LocaleHelper","require","defaultLocale","Format","constructor","template","matcher","units","handler","locales","Array","isArray","Error","RegExp","regexByLocale","getRegExp","locale","factory","compile","getMatches","string","match","toDateTime","matches","locHelper","getObject","dt","invalid","castObject","attempt","String","trim","now","Date","module","exports"],"mappings":"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","sourcesContent":["const LocaleHelper = require('../LocaleHelper/LocaleHelper.js');\nconst defaultLocale = require('../data/defaultLocale.js');\n\n/**\n * Represents a parsable date format\n */\nclass Format {\n\t/**\n\t * Given a definition, create a parsable format\n\t * @param {Object} definition  The format definition\n\t * @property {String} template  A template for RegExp that can handle multiple languages\n\t * @property {RegExp} matcher  An actual RegExp to match against\n\t * @property {Array} units  If the template or RegExp match exact units, you can define the units\n\t * @property {Function} handler  A flexible alternative to units; must return an object\n\t * @property {Array} locales  A list of locales that this format should be restricted to\n\t */\n\tconstructor({\n\t\ttemplate = null,\n\t\tmatcher = null,\n\t\tunits = null,\n\t\thandler = null,\n\t\tlocales = null,\n\t}) {\n\t\tif (!Array.isArray(units) && typeof handler !== 'function') {\n\t\t\tthrow new Error(\n\t\t\t\t'new Format must receive a \"units\" array or \"handler\" function'\n\t\t\t);\n\t\t}\n\t\tif (typeof template !== 'string' && !(matcher instanceof RegExp)) {\n\t\t\tthrow new Error(\n\t\t\t\t'new Format must receive a \"template\" string or \"matcher\" RegExp'\n\t\t\t);\n\t\t}\n\t\t/**\n\t\t * @type {String} template  A template for RegExp that can handle multiple languages\n\t\t */\n\t\tthis.template = template;\n\n\t\t/**\n\t\t * @type {Array} units  If the template or RegExp match exact units, you can define the units\n\t\t */\n\t\tthis.units = units;\n\n\t\t/**\n\t\t * @type {RegExp} matcher  An actual RegExp to match against\n\t\t */\n\t\tthis.matcher = matcher;\n\n\t\t/**\n\t\t * @type {Function} handler  A flexible alternative to units; must return an object\n\t\t */\n\t\tthis.handler = handler;\n\n\t\t/**\n\t\t * @type {String[]} locales  A list of locales that this format should be restricted to\n\t\t */\n\t\tthis.locales = locales;\n\n\t\t/**\n\t\t * A cache of RegExp indexed by locale name\n\t\t * @type {Object}\n\t\t */\n\t\tthis.regexByLocale = {};\n\t}\n\n\t/**\n\t * Build the RegExp from the template for a given locale\n\t * @param {String} locale  The language locale such as en-US, pt-BR, zh, es, etc.\n\t * @returns {RegExp}  A RegExp that matches when this format is recognized\n\t */\n\tgetRegExp(locale = defaultLocale) {\n\t\tif (this.template) {\n\t\t\tif (!this.regexByLocale[locale]) {\n\t\t\t\tthis.regexByLocale[locale] = LocaleHelper.factory(locale).compile(\n\t\t\t\t\tthis.template\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn this.regexByLocale[locale];\n\t\t}\n\t\treturn this.matcher;\n\t}\n\n\t/**\n\t * Run this format's RegExp against the given string\n\t * @param {String} string  The date string\n\t * @param {String} locale  The language locale such as en-US, pt-BR, zh, es, etc.\n\t * @returns {Array|null}  Array of matches or null on non-match\n\t */\n\tgetMatches(string, locale = defaultLocale) {\n\t\treturn string.match(this.getRegExp(locale));\n\t}\n\n\t/**\n\t * Given matches against this RegExp, convert to object\n\t * @param {String[]} matches  An array of matched parts\n\t * @param {String} locale  The language locale such as en-US, pt-BR, zh, es, etc.\n\t * @returns {Object}  Object which may contain year, month, day, hour, minute, second, millisecond, offset, invalid\n\t */\n\ttoDateTime(matches, locale = defaultLocale) {\n\t\tconst locHelper = LocaleHelper.factory(locale);\n\t\tif (this.units) {\n\t\t\treturn locHelper.getObject(this.units, matches);\n\t\t}\n\t\tconst dt = this.handler(matches, locale);\n\t\tif (!dt || dt.invalid) {\n\t\t\treturn dt;\n\t\t}\n\t\treturn locHelper.castObject(dt);\n\t}\n\n\t/**\n\t * Attempt to parse a string in this format\n\t * @param {String} string  The date string\n\t * @param {String} locale  The language locale such as en-US, pt-BR, zh, es, etc.\n\t * @returns {Object|null}  Null if format can't handle this string, Object for result or error\n\t */\n\tattempt(string, locale = defaultLocale) {\n\t\tstring = String(string).trim();\n\t\tconst matches = this.getMatches(string, locale);\n\t\tif (matches) {\n\t\t\tconst dt = this.toDateTime(matches, locale);\n\t\t\tif (dt && !dt.invalid) {\n\t\t\t\treturn dt;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Return the current date (used to support unit testing)\n\t * @returns {Date}\n\t */\n\tnow() {\n\t\treturn new Date();\n\t}\n}\n\nmodule.exports = Format;\n"]},"metadata":{},"sourceType":"script"}