{"ast":null,"code":"import _slicedToArray from \"/home/mike/proj/frontend/ui/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _toConsumableArray from \"/home/mike/proj/frontend/ui/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _objectSpread from \"/home/mike/proj/frontend/ui/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"/home/mike/proj/frontend/ui/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _createClass from \"/home/mike/proj/frontend/ui/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"/home/mike/proj/frontend/ui/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _inherits from \"/home/mike/proj/frontend/ui/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/home/mike/proj/frontend/ui/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _wrapNativeSuper from \"/home/mike/proj/frontend/ui/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js\";\nimport _regeneratorRuntime from \"/home/mike/proj/frontend/ui/node_modules/@babel/runtime/regenerator/index.js\";\n\nvar ResumableError = /*#__PURE__*/function (_Error) {\n  _inherits(ResumableError, _Error);\n\n  var _super = _createSuper(ResumableError);\n\n  function ResumableError() {\n    _classCallCheck(this, ResumableError);\n\n    return _super.apply(this, arguments);\n  }\n\n  return _createClass(ResumableError);\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nvar FatalError = /*#__PURE__*/function (_Error2) {\n  _inherits(FatalError, _Error2);\n\n  var _super2 = _createSuper(FatalError);\n\n  function FatalError() {\n    _classCallCheck(this, FatalError);\n\n    return _super2.apply(this, arguments);\n  }\n\n  return _createClass(FatalError);\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nvar lib = {};\nObject.defineProperty(lib, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n/* global window self */\n\n\nvar isBrowser = typeof window !== 'undefined' && typeof window.document !== 'undefined';\n/* eslint-disable no-restricted-globals */\n\nvar isWebWorker = (typeof self === 'undefined' ? 'undefined' : _typeof(self)) === 'object' && self.constructor && self.constructor.name === 'DedicatedWorkerGlobalScope';\n/* eslint-enable no-restricted-globals */\n\nvar isNode = typeof process !== 'undefined' && process.versions != null && process.versions.node != null;\n/**\n * @see https://github.com/jsdom/jsdom/releases/tag/12.0.0\n * @see https://github.com/jsdom/jsdom/issues/1537\n */\n\n/* eslint-disable no-undef */\n\nvar isJsDom = function isJsDom() {\n  return typeof window !== 'undefined' && window.name === 'nodejs' || navigator.userAgent.includes('Node.js') || navigator.userAgent.includes('jsdom');\n};\n\nvar isBrowser_1 = lib.isBrowser = isBrowser;\nlib.isWebWorker = isWebWorker;\nlib.isNode = isNode;\nlib.isJsDom = isJsDom;\n\nfunction getBytes(_x, _x2) {\n  return _getBytes.apply(this, arguments);\n}\n\nfunction _getBytes() {\n  _getBytes = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee16(stream, onChunk) {\n    var reader, result;\n    return _regeneratorRuntime.wrap(function _callee16$(_context16) {\n      while (1) {\n        switch (_context16.prev = _context16.next) {\n          case 0:\n            reader = stream.getReader();\n\n          case 1:\n            _context16.next = 3;\n            return reader.read();\n\n          case 3:\n            if ((result = _context16.sent).done) {\n              _context16.next = 7;\n              break;\n            }\n\n            onChunk(result.value);\n            _context16.next = 1;\n            break;\n\n          case 7:\n          case \"end\":\n            return _context16.stop();\n        }\n      }\n    }, _callee16);\n  }));\n  return _getBytes.apply(this, arguments);\n}\n\nfunction getLines(onLine) {\n  var buffer;\n  var position;\n  var fieldLength;\n  var discardTrailingNewline = false;\n  return function onChunk(arr) {\n    if (buffer === undefined) {\n      buffer = arr;\n      position = 0;\n      fieldLength = -1;\n    } else {\n      buffer = concat(buffer, arr);\n    }\n\n    var bufLength = buffer.length;\n    var lineStart = 0;\n\n    while (position < bufLength) {\n      if (discardTrailingNewline) {\n        if (buffer[position] === 10) {\n          lineStart = ++position;\n        }\n\n        discardTrailingNewline = false;\n      }\n\n      var lineEnd = -1;\n\n      for (; position < bufLength && lineEnd === -1; ++position) {\n        switch (buffer[position]) {\n          case 58:\n            if (fieldLength === -1) {\n              fieldLength = position - lineStart;\n            }\n\n            break;\n\n          case 13:\n            discardTrailingNewline = true;\n\n          case 10:\n            lineEnd = position;\n            break;\n        }\n      }\n\n      if (lineEnd === -1) {\n        break;\n      }\n\n      onLine(buffer.subarray(lineStart, lineEnd), fieldLength);\n      lineStart = position;\n      fieldLength = -1;\n    }\n\n    if (lineStart === bufLength) {\n      buffer = undefined;\n    } else if (lineStart !== 0) {\n      buffer = buffer.subarray(lineStart);\n      position -= lineStart;\n    }\n  };\n}\n\nfunction getMessages(onId, onRetry, onMessage) {\n  var message = newMessage();\n  var decoder = new TextDecoder();\n  return function onLine(line, fieldLength) {\n    if (line.length === 0) {\n      onMessage === null || onMessage === void 0 ? void 0 : onMessage(message);\n      message = newMessage();\n    } else if (fieldLength > 0) {\n      var field = decoder.decode(line.subarray(0, fieldLength));\n      var valueOffset = fieldLength + (line[fieldLength + 1] === 32 ? 2 : 1);\n      var value = decoder.decode(line.subarray(valueOffset));\n\n      switch (field) {\n        case 'data':\n          message.data = message.data ? message.data + '\\n' + value : value;\n          break;\n\n        case 'event':\n          message.event = value;\n          break;\n\n        case 'id':\n          onId(message.id = value);\n          break;\n\n        case 'retry':\n          var retry = parseInt(value, 10);\n\n          if (!isNaN(retry)) {\n            onRetry(message.retry = retry);\n          }\n\n          break;\n      }\n    }\n  };\n}\n\nfunction concat(a, b) {\n  var res = new Uint8Array(a.length + b.length);\n  res.set(a);\n  res.set(b, a.length);\n  return res;\n}\n\nfunction newMessage() {\n  return {\n    data: '',\n    event: '',\n    id: '',\n    retry: undefined\n  };\n}\n\nvar __rest = undefined && undefined.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nvar EventStreamContentType = 'text/event-stream';\nvar DefaultRetryInterval = 1000;\nvar LastEventId = 'last-event-id';\n\nfunction fetchEventSource(input, _a) {\n  var inputSignal = _a.signal,\n      inputHeaders = _a.headers,\n      inputOnOpen = _a.onopen,\n      onmessage = _a.onmessage,\n      onclose = _a.onclose,\n      onerror = _a.onerror,\n      openWhenHidden = _a.openWhenHidden,\n      inputFetch = _a.fetch,\n      rest = __rest(_a, [\"signal\", \"headers\", \"onopen\", \"onmessage\", \"onclose\", \"onerror\", \"openWhenHidden\", \"fetch\"]);\n\n  return new Promise(function (resolve, reject) {\n    var headers = Object.assign({}, inputHeaders);\n\n    if (!headers.accept) {\n      headers.accept = EventStreamContentType;\n    }\n\n    var curRequestController;\n\n    function onVisibilityChange() {\n      curRequestController.abort();\n\n      if (!document.hidden) {\n        create();\n      }\n    }\n\n    if (!openWhenHidden) {\n      document.addEventListener('visibilitychange', onVisibilityChange);\n    }\n\n    var retryInterval = DefaultRetryInterval;\n    var retryTimer = 0;\n\n    function dispose() {\n      document.removeEventListener('visibilitychange', onVisibilityChange);\n      window.clearTimeout(retryTimer);\n      curRequestController.abort();\n    }\n\n    inputSignal === null || inputSignal === void 0 ? void 0 : inputSignal.addEventListener('abort', function () {\n      dispose();\n      resolve();\n    });\n    var fetch = inputFetch !== null && inputFetch !== void 0 ? inputFetch : window.fetch;\n    var onopen = inputOnOpen !== null && inputOnOpen !== void 0 ? inputOnOpen : defaultOnOpen;\n\n    function create() {\n      return _create.apply(this, arguments);\n    }\n\n    function _create() {\n      _create = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var _a, response, interval;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                curRequestController = new AbortController();\n                _context.prev = 1;\n                _context.next = 4;\n                return fetch(input, Object.assign(Object.assign({}, rest), {\n                  headers: headers,\n                  signal: curRequestController.signal\n                }));\n\n              case 4:\n                response = _context.sent;\n                _context.next = 7;\n                return onopen(response);\n\n              case 7:\n                _context.next = 9;\n                return getBytes(response.body, getLines(getMessages(function (id) {\n                  if (id) {\n                    headers[LastEventId] = id;\n                  } else {\n                    delete headers[LastEventId];\n                  }\n                }, function (retry) {\n                  retryInterval = retry;\n                }, onmessage)));\n\n              case 9:\n                onclose === null || onclose === void 0 ? void 0 : onclose();\n                dispose();\n                resolve();\n                _context.next = 17;\n                break;\n\n              case 14:\n                _context.prev = 14;\n                _context.t0 = _context[\"catch\"](1);\n\n                if (!curRequestController.signal.aborted) {\n                  try {\n                    interval = (_a = onerror === null || onerror === void 0 ? void 0 : onerror(_context.t0)) !== null && _a !== void 0 ? _a : retryInterval;\n                    window.clearTimeout(retryTimer);\n                    retryTimer = window.setTimeout(create, interval);\n                  } catch (innerErr) {\n                    dispose();\n                    reject(innerErr);\n                  }\n                }\n\n              case 17:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, null, [[1, 14]]);\n      }));\n      return _create.apply(this, arguments);\n    }\n\n    create();\n  });\n}\n\nfunction defaultOnOpen(response) {\n  var contentType = response.headers.get('content-type');\n\n  if (!(contentType === null || contentType === void 0 ? void 0 : contentType.startsWith(EventStreamContentType))) {\n    throw new Error(\"Expected content-type to be \".concat(EventStreamContentType, \", Actual: \").concat(contentType));\n  }\n}\n/**\r\n * Returns a hex string of given length.\r\n *\r\n * Poached from StackOverflow.\r\n *\r\n * @param len Length of hex string to return.\r\n */\n\n\nfunction hexString(len) {\n  var maxlen = 8;\n  var min = Math.pow(16, Math.min(len, maxlen) - 1);\n  var max = Math.pow(16, Math.min(len, maxlen)) - 1;\n  var n = Math.floor(Math.random() * (max - min + 1)) + min;\n  var r = n.toString(16);\n\n  while (r.length < len) {\n    r = r + hexString(len - maxlen);\n  }\n\n  return r;\n}\n/**\r\n * A class for interacting with an urbit ship, given its URL and code\r\n */\n\n\nvar Urbit = /*#__PURE__*/function () {\n  /**\r\n   * Constructs a new Urbit connection.\r\n   *\r\n   * @param url  The URL (with protocol and port) of the ship to be accessed. If\r\n   * the airlock is running in a webpage served by the ship, this should just\r\n   * be the empty string.\r\n   * @param code The access code for the ship at that address\r\n   */\n  function Urbit(url, code, desk) {\n    _classCallCheck(this, Urbit);\n\n    this.url = url;\n    this.code = code;\n    this.desk = desk;\n    /**\r\n     * UID will be used for the channel: The current unix time plus a random hex string\r\n     */\n\n    this.uid = \"\".concat(Math.floor(Date.now() / 1000), \"-\").concat(hexString(6));\n    /**\r\n     * Last Event ID is an auto-updated index of which events have been sent over this channel\r\n     */\n\n    this.lastEventId = 0;\n    this.lastAcknowledgedEventId = 0;\n    /**\r\n     * SSE Client is null for now; we don't want to start polling until it the channel exists\r\n     */\n\n    this.sseClientInitialized = false;\n    /**\r\n     * A registry of requestId to successFunc/failureFunc\r\n     *\r\n     * These functions are registered during a +poke and are executed\r\n     * in the onServerEvent()/onServerError() callbacks. Only one of\r\n     * the functions will be called, and the outstanding poke will be\r\n     * removed after calling the success or failure function.\r\n     */\n\n    this.outstandingPokes = new Map();\n    /**\r\n     * A registry of requestId to subscription functions.\r\n     *\r\n     * These functions are registered during a +subscribe and are\r\n     * executed in the onServerEvent()/onServerError() callbacks. The\r\n     * event function will be called whenever a new piece of data on this\r\n     * subscription is available, which may be 0, 1, or many times. The\r\n     * disconnect function may be called exactly once.\r\n     */\n\n    this.outstandingSubscriptions = new Map();\n    /**\r\n     * Our abort controller, used to close the connection\r\n     */\n\n    this.abort = new AbortController();\n    /**\r\n     * number of consecutive errors in connecting to the eventsource\r\n     */\n\n    this.errorCount = 0;\n    this.onError = null;\n    this.onRetry = null;\n    this.onOpen = null;\n\n    if (isBrowser_1) {\n      window.addEventListener('beforeunload', this.delete);\n    }\n\n    return this;\n  }\n  /** This is basic interpolation to get the channel URL of an instantiated Urbit connection. */\n\n\n  _createClass(Urbit, [{\n    key: \"channelUrl\",\n    get: function get() {\n      return \"\".concat(this.url, \"/~/channel/\").concat(this.uid);\n    }\n  }, {\n    key: \"fetchOptions\",\n    get: function get() {\n      var headers = {\n        'Content-Type': 'application/json'\n      };\n\n      if (!isBrowser_1) {\n        headers.Cookie = this.cookie;\n      }\n\n      return {\n        credentials: 'include',\n        accept: '*',\n        headers: headers,\n        signal: this.abort.signal\n      };\n    }\n    /**\r\n     * All-in-one hook-me-up.\r\n     *\r\n     * Given a ship, url, and code, this returns an airlock connection\r\n     * that is ready to go. It `|hi`s itself to create the channel,\r\n     * then opens the channel via EventSource.\r\n     *\r\n     */\n\n  }, {\n    key: \"connect\",\n    value:\n    /**\r\n     * Connects to the Urbit ship. Nothing can be done until this is called.\r\n     * That's why we roll it into this.authenticate\r\n     */\n    function () {\n      var _connect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var _this = this;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (this.verbose) {\n                  console.log(\"password=\".concat(this.code, \" \"), isBrowser_1 ? 'Connecting in browser context at ' + \"\".concat(this.url, \"/~/login\") : 'Connecting from node context');\n                }\n\n                return _context2.abrupt(\"return\", fetch(\"\".concat(this.url, \"/~/login\"), {\n                  method: 'post',\n                  body: \"password=\".concat(this.code),\n                  credentials: 'include'\n                }).then(function (response) {\n                  if (_this.verbose) {\n                    console.log('Received authentication response', response);\n                  }\n\n                  var cookie = response.headers.get('set-cookie');\n\n                  if (!_this.ship) {\n                    _this.ship = new RegExp(/urbauth-~([\\w-]+)/).exec(cookie)[1];\n                  }\n\n                  if (!isBrowser_1) {\n                    _this.cookie = cookie;\n                  }\n                }));\n\n              case 2:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function connect() {\n        return _connect.apply(this, arguments);\n      }\n\n      return connect;\n    }()\n    /**\r\n     * Initializes the SSE pipe for the appropriate channel.\r\n     */\n\n  }, {\n    key: \"eventSource\",\n    value: function () {\n      var _eventSource = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        var _this2 = this;\n\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (!this.sseClientInitialized) {\n                  _context4.next = 2;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\", Promise.resolve());\n\n              case 2:\n                if (!(this.lastEventId === 0)) {\n                  _context4.next = 6;\n                  break;\n                }\n\n                _context4.next = 5;\n                return this.poke({\n                  app: 'hood',\n                  mark: 'helm-hi',\n                  json: 'Opening API channel'\n                });\n\n              case 5:\n                return _context4.abrupt(\"return\");\n\n              case 6:\n                this.sseClientInitialized = true;\n                return _context4.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  fetchEventSource(_this2.channelUrl, _objectSpread(_objectSpread({}, _this2.fetchOptions), {}, {\n                    openWhenHidden: true,\n                    onopen: function () {\n                      var _onopen = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(response) {\n                        var err;\n                        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n                          while (1) {\n                            switch (_context3.prev = _context3.next) {\n                              case 0:\n                                if (_this2.verbose) {\n                                  console.log('Opened eventsource', response);\n                                }\n\n                                if (!response.ok) {\n                                  _context3.next = 8;\n                                  break;\n                                }\n\n                                _this2.errorCount = 0;\n                                _this2.onOpen && _this2.onOpen();\n                                resolve();\n                                return _context3.abrupt(\"return\");\n\n                              case 8:\n                                err = new Error('failed to open eventsource');\n                                reject(err);\n\n                              case 10:\n                              case \"end\":\n                                return _context3.stop();\n                            }\n                          }\n                        }, _callee3);\n                      }));\n\n                      function onopen(_x3) {\n                        return _onopen.apply(this, arguments);\n                      }\n\n                      return onopen;\n                    }(),\n                    onmessage: function onmessage(event) {\n                      if (_this2.verbose) {\n                        console.log('Received SSE: ', event);\n                      }\n\n                      if (!event.id) return;\n                      _this2.lastEventId = parseInt(event.id, 10);\n\n                      if (_this2.lastEventId - _this2.lastAcknowledgedEventId > 20) {\n                        _this2.ack(_this2.lastEventId);\n                      }\n\n                      if (event.data && JSON.parse(event.data)) {\n                        var data = JSON.parse(event.data);\n\n                        if (data.response === 'poke' && _this2.outstandingPokes.has(data.id)) {\n                          var funcs = _this2.outstandingPokes.get(data.id);\n\n                          if (data.hasOwnProperty('ok')) {\n                            funcs.onSuccess();\n                          } else if (data.hasOwnProperty('err')) {\n                            console.error(data.err);\n                            funcs.onError(data.err);\n                          } else {\n                            console.error('Invalid poke response', data);\n                          }\n\n                          _this2.outstandingPokes.delete(data.id);\n                        } else if (data.response === 'subscribe' && _this2.outstandingSubscriptions.has(data.id)) {\n                          var _funcs = _this2.outstandingSubscriptions.get(data.id);\n\n                          if (data.hasOwnProperty('err')) {\n                            console.error(data.err);\n\n                            _funcs.err(data.err, data.id);\n\n                            _this2.outstandingSubscriptions.delete(data.id);\n                          }\n                        } else if (data.response === 'diff' && _this2.outstandingSubscriptions.has(data.id)) {\n                          var _funcs2 = _this2.outstandingSubscriptions.get(data.id);\n\n                          try {\n                            _funcs2.event(data.json);\n                          } catch (e) {\n                            console.error('Failed to call subscription event callback', e);\n                          }\n                        } else if (data.response === 'quit' && _this2.outstandingSubscriptions.has(data.id)) {\n                          var _funcs3 = _this2.outstandingSubscriptions.get(data.id);\n\n                          _funcs3.quit(data);\n\n                          _this2.outstandingSubscriptions.delete(data.id);\n                        } else {\n                          console.log(_toConsumableArray(_this2.outstandingSubscriptions.keys()));\n                          console.log('Unrecognized response', data);\n                        }\n                      }\n                    },\n                    onerror: function onerror(error) {\n                      console.warn(error);\n\n                      if (_this2.errorCount++ < 4) {\n                        _this2.onRetry && _this2.onRetry();\n                        return Math.pow(2, _this2.errorCount - 1) * 750;\n                      }\n\n                      _this2.onError && _this2.onError(error);\n                      throw error;\n                    },\n                    onclose: function onclose() {\n                      console.log('e');\n                      throw new Error('Ship unexpectedly closed the connection');\n                    }\n                  }));\n                }));\n\n              case 8:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function eventSource() {\n        return _eventSource.apply(this, arguments);\n      }\n\n      return eventSource;\n    }()\n    /**\r\n     * Reset airlock, abandoning current subscriptions and wiping state\r\n     *\r\n     */\n\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.delete();\n      this.abort.abort();\n      this.abort = new AbortController();\n      this.uid = \"\".concat(Math.floor(Date.now() / 1000), \"-\").concat(hexString(6));\n      this.lastEventId = 0;\n      this.lastAcknowledgedEventId = 0;\n      this.outstandingSubscriptions = new Map();\n      this.outstandingPokes = new Map();\n      this.sseClientInitialized = false;\n    }\n    /**\r\n     * Autoincrements the next event ID for the appropriate channel.\r\n     */\n\n  }, {\n    key: \"getEventId\",\n    value: function getEventId() {\n      this.lastEventId = Number(this.lastEventId) + 1;\n      return this.lastEventId;\n    }\n    /**\r\n     * Acknowledges an event.\r\n     *\r\n     * @param eventId The event to acknowledge.\r\n     */\n\n  }, {\n    key: \"ack\",\n    value: function () {\n      var _ack = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(eventId) {\n        var message;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                this.lastAcknowledgedEventId = eventId;\n                message = {\n                  action: 'ack',\n                  'event-id': eventId\n                };\n                _context5.next = 4;\n                return this.sendJSONtoChannel(message);\n\n              case 4:\n                return _context5.abrupt(\"return\", eventId);\n\n              case 5:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function ack(_x4) {\n        return _ack.apply(this, arguments);\n      }\n\n      return ack;\n    }()\n  }, {\n    key: \"sendJSONtoChannel\",\n    value: function () {\n      var _sendJSONtoChannel = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {\n        var _len,\n            json,\n            _key,\n            response,\n            _args6 = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                for (_len = _args6.length, json = new Array(_len), _key = 0; _key < _len; _key++) {\n                  json[_key] = _args6[_key];\n                }\n\n                _context6.next = 3;\n                return fetch(this.channelUrl, _objectSpread(_objectSpread({}, this.fetchOptions), {}, {\n                  method: 'PUT',\n                  body: JSON.stringify(json)\n                }));\n\n              case 3:\n                response = _context6.sent;\n\n                if (response.ok) {\n                  _context6.next = 6;\n                  break;\n                }\n\n                throw new Error('Failed to PUT channel');\n\n              case 6:\n                if (this.sseClientInitialized) {\n                  _context6.next = 9;\n                  break;\n                }\n\n                _context6.next = 9;\n                return this.eventSource();\n\n              case 9:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function sendJSONtoChannel() {\n        return _sendJSONtoChannel.apply(this, arguments);\n      }\n\n      return sendJSONtoChannel;\n    }()\n    /**\r\n     * Creates a subscription, waits for a fact and then unsubscribes\r\n     *\r\n     * @param app Name of gall agent to subscribe to\r\n     * @param path Path to subscribe to\r\n     * @param timeout Optional timeout before ending subscription\r\n     *\r\n     * @returns The first fact on the subcription\r\n     */\n\n  }, {\n    key: \"subscribeOnce\",\n    value: function () {\n      var _subscribeOnce = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(app, path, timeout) {\n        var _this3 = this;\n\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                return _context8.abrupt(\"return\", new Promise( /*#__PURE__*/function () {\n                  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(resolve, reject) {\n                    var done, id, quit, event, request;\n                    return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n                      while (1) {\n                        switch (_context7.prev = _context7.next) {\n                          case 0:\n                            done = false;\n                            id = null;\n\n                            quit = function quit() {\n                              if (!done) {\n                                reject('quit');\n                              }\n                            };\n\n                            event = function event(e) {\n                              if (!done) {\n                                resolve(e);\n\n                                _this3.unsubscribe(id);\n                              }\n                            };\n\n                            request = {\n                              app: app,\n                              path: path,\n                              event: event,\n                              err: reject,\n                              quit: quit\n                            };\n                            _context7.next = 7;\n                            return _this3.subscribe(request);\n\n                          case 7:\n                            id = _context7.sent;\n\n                            if (timeout) {\n                              setTimeout(function () {\n                                if (!done) {\n                                  done = true;\n                                  reject('timeout');\n\n                                  _this3.unsubscribe(id);\n                                }\n                              }, timeout);\n                            }\n\n                          case 9:\n                          case \"end\":\n                            return _context7.stop();\n                        }\n                      }\n                    }, _callee7);\n                  }));\n\n                  return function (_x8, _x9) {\n                    return _ref.apply(this, arguments);\n                  };\n                }()));\n\n              case 1:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8);\n      }));\n\n      function subscribeOnce(_x5, _x6, _x7) {\n        return _subscribeOnce.apply(this, arguments);\n      }\n\n      return subscribeOnce;\n    }()\n    /**\r\n     * Pokes a ship with data.\r\n     *\r\n     * @param app The app to poke\r\n     * @param mark The mark of the data being sent\r\n     * @param json The data to send\r\n     */\n\n  }, {\n    key: \"poke\",\n    value: function () {\n      var _poke = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9(params) {\n        var _this4 = this;\n\n        var _onSuccess$onError$sh, app, mark, json, ship, _onSuccess, _onError, message, _yield$Promise$all, _yield$Promise$all2, send, result;\n\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                _onSuccess$onError$sh = _objectSpread({\n                  onSuccess: function onSuccess() {},\n                  onError: function onError() {},\n                  ship: this.ship\n                }, params), app = _onSuccess$onError$sh.app, mark = _onSuccess$onError$sh.mark, json = _onSuccess$onError$sh.json, ship = _onSuccess$onError$sh.ship, _onSuccess = _onSuccess$onError$sh.onSuccess, _onError = _onSuccess$onError$sh.onError;\n                message = {\n                  id: this.getEventId(),\n                  action: 'poke',\n                  ship: ship,\n                  app: app,\n                  mark: mark,\n                  json: json\n                };\n                _context9.next = 4;\n                return Promise.all([this.sendJSONtoChannel(message), new Promise(function (resolve, reject) {\n                  _this4.outstandingPokes.set(message.id, {\n                    onSuccess: function onSuccess() {\n                      _onSuccess();\n\n                      resolve(message.id);\n                    },\n                    onError: function onError(event) {\n                      _onError(event);\n\n                      reject(event.err);\n                    }\n                  });\n                })]);\n\n              case 4:\n                _yield$Promise$all = _context9.sent;\n                _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);\n                send = _yield$Promise$all2[0];\n                result = _yield$Promise$all2[1];\n                return _context9.abrupt(\"return\", result);\n\n              case 9:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function poke(_x10) {\n        return _poke.apply(this, arguments);\n      }\n\n      return poke;\n    }()\n    /**\r\n     * Subscribes to a path on an app on a ship.\r\n     *\r\n     *\r\n     * @param app The app to subsribe to\r\n     * @param path The path to which to subscribe\r\n     * @param handlers Handlers to deal with various events of the subscription\r\n     */\n\n  }, {\n    key: \"subscribe\",\n    value: function () {\n      var _subscribe = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10(params) {\n        var _err$event$quit$ship$, app, path, ship, err, event, quit, message;\n\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                _err$event$quit$ship$ = _objectSpread({\n                  err: function err() {},\n                  event: function event() {},\n                  quit: function quit() {},\n                  ship: this.ship\n                }, params), app = _err$event$quit$ship$.app, path = _err$event$quit$ship$.path, ship = _err$event$quit$ship$.ship, err = _err$event$quit$ship$.err, event = _err$event$quit$ship$.event, quit = _err$event$quit$ship$.quit;\n                message = {\n                  id: this.getEventId(),\n                  action: 'subscribe',\n                  ship: ship,\n                  app: app,\n                  path: path\n                };\n                this.outstandingSubscriptions.set(message.id, {\n                  app: app,\n                  path: path,\n                  err: err,\n                  event: event,\n                  quit: quit\n                });\n                _context10.next = 5;\n                return this.sendJSONtoChannel(message);\n\n              case 5:\n                return _context10.abrupt(\"return\", message.id);\n\n              case 6:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      function subscribe(_x11) {\n        return _subscribe.apply(this, arguments);\n      }\n\n      return subscribe;\n    }()\n    /**\r\n     * Unsubscribes to a given subscription.\r\n     *\r\n     * @param subscription\r\n     */\n\n  }, {\n    key: \"unsubscribe\",\n    value: function () {\n      var _unsubscribe = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11(subscription) {\n        var _this5 = this;\n\n        return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                return _context11.abrupt(\"return\", this.sendJSONtoChannel({\n                  id: this.getEventId(),\n                  action: 'unsubscribe',\n                  subscription: subscription\n                }).then(function () {\n                  _this5.outstandingSubscriptions.delete(subscription);\n                }));\n\n              case 1:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n\n      function unsubscribe(_x12) {\n        return _unsubscribe.apply(this, arguments);\n      }\n\n      return unsubscribe;\n    }()\n    /**\r\n     * Deletes the connection to a channel.\r\n     */\n\n  }, {\n    key: \"delete\",\n    value: function _delete() {\n      if (isBrowser_1) {\n        navigator.sendBeacon(this.channelUrl, JSON.stringify([{\n          action: 'delete'\n        }]));\n      }\n    }\n    /**\r\n     * Scry into an gall agent at a path\r\n     *\r\n     * @typeParam T - Type of the scry result\r\n     *\r\n     * @remarks\r\n     *\r\n     * Equivalent to\r\n     * ```hoon\r\n     * .^(T %gx /(scot %p our)/[app]/(scot %da now)/[path]/json)\r\n     * ```\r\n     * The returned cage must have a conversion to JSON for the scry to succeed\r\n     *\r\n     * @param params The scry request\r\n     * @returns The scry result\r\n     */\n\n  }, {\n    key: \"scry\",\n    value: function () {\n      var _scry = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee12(params) {\n        var app, path, response;\n        return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                app = params.app, path = params.path;\n                _context12.next = 3;\n                return fetch(\"\".concat(this.url, \"/~/scry/\").concat(app).concat(path, \".json\"), this.fetchOptions);\n\n              case 3:\n                response = _context12.sent;\n                _context12.next = 6;\n                return response.json();\n\n              case 6:\n                return _context12.abrupt(\"return\", _context12.sent);\n\n              case 7:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this);\n      }));\n\n      function scry(_x13) {\n        return _scry.apply(this, arguments);\n      }\n\n      return scry;\n    }()\n    /**\r\n     * Run a thread\r\n     *\r\n     *\r\n     * @param inputMark   The mark of the data being sent\r\n     * @param outputMark  The mark of the data being returned\r\n     * @param threadName  The thread to run\r\n     * @param body        The data to send to the thread\r\n     * @returns  The return value of the thread\r\n     */\n\n  }, {\n    key: \"thread\",\n    value: function () {\n      var _thread = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee13(params) {\n        var inputMark, outputMark, threadName, body, _params$desk, desk, res;\n\n        return _regeneratorRuntime.wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                inputMark = params.inputMark, outputMark = params.outputMark, threadName = params.threadName, body = params.body, _params$desk = params.desk, desk = _params$desk === void 0 ? this.desk : _params$desk;\n\n                if (desk) {\n                  _context13.next = 3;\n                  break;\n                }\n\n                throw new Error('Must supply desk to run thread from');\n\n              case 3:\n                _context13.next = 5;\n                return fetch(\"\".concat(this.url, \"/spider/\").concat(desk, \"/\").concat(inputMark, \"/\").concat(threadName, \"/\").concat(outputMark, \".json\"), _objectSpread(_objectSpread({}, this.fetchOptions), {}, {\n                  method: 'POST',\n                  body: JSON.stringify(body)\n                }));\n\n              case 5:\n                res = _context13.sent;\n                return _context13.abrupt(\"return\", res.json());\n\n              case 7:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this);\n      }));\n\n      function thread(_x14) {\n        return _thread.apply(this, arguments);\n      }\n\n      return thread;\n    }()\n    /**\r\n     * Utility function to connect to a ship that has its *.arvo.network domain configured.\r\n     *\r\n     * @param name Name of the ship e.g. zod\r\n     * @param code Code to log in\r\n     */\n\n  }], [{\n    key: \"authenticate\",\n    value: function () {\n      var _authenticate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee14(_ref2) {\n        var ship, url, code, _ref2$verbose, verbose, airlock;\n\n        return _regeneratorRuntime.wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                ship = _ref2.ship, url = _ref2.url, code = _ref2.code, _ref2$verbose = _ref2.verbose, verbose = _ref2$verbose === void 0 ? false : _ref2$verbose;\n                airlock = new Urbit(\"http://\".concat(url), code);\n                airlock.verbose = verbose;\n                airlock.ship = ship;\n                _context14.next = 6;\n                return airlock.connect();\n\n              case 6:\n                _context14.next = 8;\n                return airlock.poke({\n                  app: 'hood',\n                  mark: 'helm-hi',\n                  json: 'opening airlock'\n                });\n\n              case 8:\n                _context14.next = 10;\n                return airlock.eventSource();\n\n              case 10:\n                return _context14.abrupt(\"return\", airlock);\n\n              case 11:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14);\n      }));\n\n      function authenticate(_x15) {\n        return _authenticate.apply(this, arguments);\n      }\n\n      return authenticate;\n    }()\n  }, {\n    key: \"onArvoNetwork\",\n    value: function () {\n      var _onArvoNetwork = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee15(ship, code) {\n        var url;\n        return _regeneratorRuntime.wrap(function _callee15$(_context15) {\n          while (1) {\n            switch (_context15.prev = _context15.next) {\n              case 0:\n                url = \"https://\".concat(ship, \".arvo.network\");\n                _context15.next = 3;\n                return Urbit.authenticate({\n                  ship: ship,\n                  url: url,\n                  code: code\n                });\n\n              case 3:\n                return _context15.abrupt(\"return\", _context15.sent);\n\n              case 4:\n              case \"end\":\n                return _context15.stop();\n            }\n          }\n        }, _callee15);\n      }));\n\n      function onArvoNetwork(_x16, _x17) {\n        return _onArvoNetwork.apply(this, arguments);\n      }\n\n      return onArvoNetwork;\n    }()\n  }]);\n\n  return Urbit;\n}();\n\nexport { FatalError, ResumableError, Urbit, Urbit as default };","map":null,"metadata":{},"sourceType":"module"}