{"ast":null,"code":"const defaultLocale = require('../data/defaultLocale.js');\n\nconst Format = require('../Format/Format.js'); // required to generate index.d.ts\n\n\nconst fromString = require('../fromString/fromString.js');\n\nconst fromAny = require('../fromAny/fromAny.js');\n\nclass Parser {\n  /**\n   * Initialize an object with an empty array of registered formats\n   */\n  constructor() {\n    this.formats = [];\n  }\n  /**\n   * Register a format object representing a parseable date format\n   * @param {Format} format  The Format to add\n   * @returns {Parser}\n   * @chainable\n   */\n\n\n  addFormat(format) {\n    this.formats.push(format);\n    format.parser = this;\n    return this;\n  }\n  /**\n   * Register multiple formats\n   * @param {Format[]} formats  The array of Formats to add\n   * @returns {Parser}\n   * @chainable\n   */\n\n\n  addFormats(formats) {\n    formats.forEach(format => this.addFormat(format));\n    return this;\n  }\n  /**\n   * Unregister a format\n   * @param {Format} format  The Format to remove\n   * @returns {Boolean}  true if format was found and removed, false if it wasn't registered\n   */\n\n\n  removeFormat(format) {\n    const idx = this.formats.indexOf(format);\n\n    if (idx > -1) {\n      const old = this.formats[idx];\n      this.formats.splice(idx, 1);\n      old.parser = null;\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Attempt to parse a date string\n   * @param {String} date  A parseable date string\n   * @param {String} locale  The name of the locale\n   * @returns {Object}\n   */\n\n\n  attempt(date) {\n    let locale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultLocale;\n\n    for (const format of this.formats) {\n      if (Array.isArray(format.locales) && format.locales.length > 0 && !format.locales.includes(new Intl.Locale(locale).baseName)) {\n        // some formats only make sense for certain locales, e.g. month/day/year\n        continue;\n      }\n\n      const dt = format.attempt(date, locale);\n\n      if (dt) {\n        return dt;\n      }\n    } // Uh Oh! We don't know that one\n\n\n    let string = String(date).slice(0, 200);\n\n    if (string === '') {\n      string = 'empty string';\n    }\n\n    return {\n      invalid: `Unable to parse ${string}`\n    };\n  }\n  /**\n   * Export this parser as a single function that takes a string\n   * @param {String} locale  The default locale it should use\n   * @returns {Function}\n   */\n\n\n  exportAsFunction() {\n    let locale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultLocale;\n    return fromString(this, locale);\n  }\n  /**\n   * Export this parser as a single function that takes a string or Date\n   * @param {String} locale  The default locale it should use\n   * @returns {Function}\n   */\n\n\n  exportAsFunctionAny() {\n    let locale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultLocale;\n    return fromAny(fromString(this, locale));\n  }\n\n}\n\nmodule.exports = Parser;","map":{"version":3,"sources":["/home/mike/proj/frontend/ui/node_modules/any-date-parser/src/Parser/Parser.js"],"names":["defaultLocale","require","Format","fromString","fromAny","Parser","constructor","formats","addFormat","format","push","parser","addFormats","forEach","removeFormat","idx","indexOf","old","splice","attempt","date","locale","Array","isArray","locales","length","includes","Intl","Locale","baseName","dt","string","String","slice","invalid","exportAsFunction","exportAsFunctionAny","module","exports"],"mappings":"AAAA,MAAMA,aAAa,GAAGC,OAAO,CAAC,0BAAD,CAA7B;;AACA,MAAMC,MAAM,GAAGD,OAAO,CAAC,qBAAD,CAAtB,C,CAA+C;;;AAC/C,MAAME,UAAU,GAAGF,OAAO,CAAC,6BAAD,CAA1B;;AACA,MAAMG,OAAO,GAAGH,OAAO,CAAC,uBAAD,CAAvB;;AAEA,MAAMI,MAAN,CAAa;AACZ;AACD;AACA;AACCC,EAAAA,WAAW,GAAG;AACb,SAAKC,OAAL,GAAe,EAAf;AACA;AAED;AACD;AACA;AACA;AACA;AACA;;;AACCC,EAAAA,SAAS,CAACC,MAAD,EAAS;AACjB,SAAKF,OAAL,CAAaG,IAAb,CAAkBD,MAAlB;AACAA,IAAAA,MAAM,CAACE,MAAP,GAAgB,IAAhB;AACA,WAAO,IAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;;;AACCC,EAAAA,UAAU,CAACL,OAAD,EAAU;AACnBA,IAAAA,OAAO,CAACM,OAAR,CAAgBJ,MAAM,IAAI,KAAKD,SAAL,CAAeC,MAAf,CAA1B;AACA,WAAO,IAAP;AACA;AAED;AACD;AACA;AACA;AACA;;;AACCK,EAAAA,YAAY,CAACL,MAAD,EAAS;AACpB,UAAMM,GAAG,GAAG,KAAKR,OAAL,CAAaS,OAAb,CAAqBP,MAArB,CAAZ;;AACA,QAAIM,GAAG,GAAG,CAAC,CAAX,EAAc;AACb,YAAME,GAAG,GAAG,KAAKV,OAAL,CAAaQ,GAAb,CAAZ;AACA,WAAKR,OAAL,CAAaW,MAAb,CAAoBH,GAApB,EAAyB,CAAzB;AACAE,MAAAA,GAAG,CAACN,MAAJ,GAAa,IAAb;AACA,aAAO,IAAP;AACA;;AACD,WAAO,KAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;;;AACCQ,EAAAA,OAAO,CAACC,IAAD,EAA+B;AAAA,QAAxBC,MAAwB,uEAAfrB,aAAe;;AACrC,SAAK,MAAMS,MAAX,IAAqB,KAAKF,OAA1B,EAAmC;AAClC,UACCe,KAAK,CAACC,OAAN,CAAcd,MAAM,CAACe,OAArB,KACAf,MAAM,CAACe,OAAP,CAAeC,MAAf,GAAwB,CADxB,IAEA,CAAChB,MAAM,CAACe,OAAP,CAAeE,QAAf,CAAwB,IAAIC,IAAI,CAACC,MAAT,CAAgBP,MAAhB,EAAwBQ,QAAhD,CAHF,EAIE;AACD;AACA;AACA;;AACD,YAAMC,EAAE,GAAGrB,MAAM,CAACU,OAAP,CAAeC,IAAf,EAAqBC,MAArB,CAAX;;AACA,UAAIS,EAAJ,EAAQ;AACP,eAAOA,EAAP;AACA;AACD,KAdoC,CAerC;;;AACA,QAAIC,MAAM,GAAGC,MAAM,CAACZ,IAAD,CAAN,CAAaa,KAAb,CAAmB,CAAnB,EAAsB,GAAtB,CAAb;;AACA,QAAIF,MAAM,KAAK,EAAf,EAAmB;AAClBA,MAAAA,MAAM,GAAG,cAAT;AACA;;AACD,WAAO;AAAEG,MAAAA,OAAO,EAAG,mBAAkBH,MAAO;AAArC,KAAP;AACA;AAED;AACD;AACA;AACA;AACA;;;AACCI,EAAAA,gBAAgB,GAAyB;AAAA,QAAxBd,MAAwB,uEAAfrB,aAAe;AACxC,WAAOG,UAAU,CAAC,IAAD,EAAOkB,MAAP,CAAjB;AACA;AAED;AACD;AACA;AACA;AACA;;;AACCe,EAAAA,mBAAmB,GAAyB;AAAA,QAAxBf,MAAwB,uEAAfrB,aAAe;AAC3C,WAAOI,OAAO,CAACD,UAAU,CAAC,IAAD,EAAOkB,MAAP,CAAX,CAAd;AACA;;AA5FW;;AA+FbgB,MAAM,CAACC,OAAP,GAAiBjC,MAAjB","sourcesContent":["const defaultLocale = require('../data/defaultLocale.js');\nconst Format = require('../Format/Format.js'); // required to generate index.d.ts\nconst fromString = require('../fromString/fromString.js');\nconst fromAny = require('../fromAny/fromAny.js');\n\nclass Parser {\n\t/**\n\t * Initialize an object with an empty array of registered formats\n\t */\n\tconstructor() {\n\t\tthis.formats = [];\n\t}\n\n\t/**\n\t * Register a format object representing a parseable date format\n\t * @param {Format} format  The Format to add\n\t * @returns {Parser}\n\t * @chainable\n\t */\n\taddFormat(format) {\n\t\tthis.formats.push(format);\n\t\tformat.parser = this;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Register multiple formats\n\t * @param {Format[]} formats  The array of Formats to add\n\t * @returns {Parser}\n\t * @chainable\n\t */\n\taddFormats(formats) {\n\t\tformats.forEach(format => this.addFormat(format));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Unregister a format\n\t * @param {Format} format  The Format to remove\n\t * @returns {Boolean}  true if format was found and removed, false if it wasn't registered\n\t */\n\tremoveFormat(format) {\n\t\tconst idx = this.formats.indexOf(format);\n\t\tif (idx > -1) {\n\t\t\tconst old = this.formats[idx];\n\t\t\tthis.formats.splice(idx, 1);\n\t\t\told.parser = null;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Attempt to parse a date string\n\t * @param {String} date  A parseable date string\n\t * @param {String} locale  The name of the locale\n\t * @returns {Object}\n\t */\n\tattempt(date, locale = defaultLocale) {\n\t\tfor (const format of this.formats) {\n\t\t\tif (\n\t\t\t\tArray.isArray(format.locales) &&\n\t\t\t\tformat.locales.length > 0 &&\n\t\t\t\t!format.locales.includes(new Intl.Locale(locale).baseName)\n\t\t\t) {\n\t\t\t\t// some formats only make sense for certain locales, e.g. month/day/year\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst dt = format.attempt(date, locale);\n\t\t\tif (dt) {\n\t\t\t\treturn dt;\n\t\t\t}\n\t\t}\n\t\t// Uh Oh! We don't know that one\n\t\tlet string = String(date).slice(0, 200);\n\t\tif (string === '') {\n\t\t\tstring = 'empty string';\n\t\t}\n\t\treturn { invalid: `Unable to parse ${string}` };\n\t}\n\n\t/**\n\t * Export this parser as a single function that takes a string\n\t * @param {String} locale  The default locale it should use\n\t * @returns {Function}\n\t */\n\texportAsFunction(locale = defaultLocale) {\n\t\treturn fromString(this, locale);\n\t}\n\n\t/**\n\t * Export this parser as a single function that takes a string or Date\n\t * @param {String} locale  The default locale it should use\n\t * @returns {Function}\n\t */\n\texportAsFunctionAny(locale = defaultLocale) {\n\t\treturn fromAny(fromString(this, locale));\n\t}\n}\n\nmodule.exports = Parser;\n"]},"metadata":{},"sourceType":"script"}