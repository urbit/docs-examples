{"ast":null,"code":"import dates from './dates'; // assumes both are supported or none\n\nlet supportStyles = false;\nnew Intl.DateTimeFormat(undefined, {\n  // @ts-ignore\n  get dateStyle() {\n    supportStyles = true;\n  }\n\n});\nconst dateShort = {\n  day: 'numeric',\n  month: 'numeric',\n  year: 'numeric'\n};\nconst timeShort = {\n  hour: 'numeric',\n  minute: 'numeric'\n};\n\nconst getFormatter = (culture, options) => Intl.DateTimeFormat(culture, options).format;\n/**\n * A `react-widgets` Localizer using native `Intl` APIs.\n *\n */\n\n\nclass IntlDateLocalizer {\n  constructor() {\n    let {\n      culture = undefined,\n      firstOfWeek = 0\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.culture = culture;\n\n    this.firstOfWeek = () => firstOfWeek;\n\n    function normalizeFormat(date, format) {\n      return typeof format === 'function' ? format(date, culture) : date.toLocaleString(culture, format);\n    }\n\n    const formats = {\n      date: getFormatter(culture, // @ts-ignore\n      supportStyles ? {\n        dateStyle: 'short'\n      } : dateShort),\n      time: getFormatter(culture, // @ts-ignore\n      supportStyles ? {\n        timeStyle: 'short'\n      } : timeShort),\n      datetime: getFormatter(culture, // @ts-ignore\n      supportStyles ? {\n        dateStyle: 'short',\n        timeStyle: 'short'\n      } : Object.assign({}, dateShort, timeShort)),\n      header: getFormatter(culture, {\n        month: 'short',\n        year: 'numeric'\n      }),\n      weekday: getFormatter(culture, {\n        weekday: 'narrow'\n      }),\n      dayOfMonth: getFormatter(culture, {\n        day: '2-digit'\n      }),\n      month: getFormatter(culture, {\n        month: 'short'\n      }),\n      year: getFormatter(culture, {\n        year: 'numeric'\n      }),\n      decade: date => `${this.year(date)} - ${this.year(dates.endOf(date, 'decade'))}`,\n      century: date => `${this.year(date)} - ${this.year(dates.endOf(date, 'century'))}`\n    };\n    Object.keys(formats).forEach(key => {\n      this[key] = (date, format) => format ? normalizeFormat(date, format) : formats[key](date);\n    });\n  }\n\n  toFormattedParts(date) {\n    let format = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      dateStyle: 'short',\n      timeStyle: 'short'\n    };\n    return Intl.DateTimeFormat(this.culture, format).formatToParts(date).filter(p => p.type !== 'timeZoneName');\n  }\n\n  parse(value) {\n    const date = new Date(value);\n    return isNaN(+date) ? null : date;\n  }\n\n}\n/**\n * A number localization strategy based on `Intl.NumberFormat`.\n */\n\n\nclass IntlNumberLocalizer {\n  constructor() {\n    let {\n      culture = undefined\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    var _$toLocaleString$m;\n\n    this.culture = culture;\n    const decimal = 'formatToParts' in Intl.NumberFormat(culture) ? Intl.NumberFormat(culture).formatToParts(1.1)[1].value : ((_$toLocaleString$m = 1.1.toLocaleString(culture).match(/[^\\d]/)) == null ? void 0 : _$toLocaleString$m[0]) || '.';\n    const formatter = Intl.NumberFormat(culture).format;\n\n    this.decimalCharacter = () => decimal;\n\n    this.format = (num, format) => {\n      if (format) {\n        return typeof format === 'function' ? format(num, culture) : num.toLocaleString(culture, format);\n      }\n\n      return formatter(num);\n    };\n  }\n\n  parse(value) {\n    return parseFloat(value.replace(this.decimalCharacter(), '.'));\n  }\n\n}\n\nexport { IntlDateLocalizer as DateLocalizer, IntlNumberLocalizer as NumberLocalizer };","map":{"version":3,"sources":["/home/mike/proj/frontend/ui/node_modules/react-widgets/esm/IntlLocalizer.js"],"names":["dates","supportStyles","Intl","DateTimeFormat","undefined","dateStyle","dateShort","day","month","year","timeShort","hour","minute","getFormatter","culture","options","format","IntlDateLocalizer","constructor","firstOfWeek","normalizeFormat","date","toLocaleString","formats","time","timeStyle","datetime","Object","assign","header","weekday","dayOfMonth","decade","endOf","century","keys","forEach","key","toFormattedParts","formatToParts","filter","p","type","parse","value","Date","isNaN","IntlNumberLocalizer","_$toLocaleString$m","decimal","NumberFormat","match","formatter","decimalCharacter","num","parseFloat","replace","DateLocalizer","NumberLocalizer"],"mappings":"AAAA,OAAOA,KAAP,MAAkB,SAAlB,C,CACA;;AACA,IAAIC,aAAa,GAAG,KAApB;AACA,IAAIC,IAAI,CAACC,cAAT,CAAwBC,SAAxB,EAAmC;AACjC;AACA,MAAIC,SAAJ,GAAgB;AACdJ,IAAAA,aAAa,GAAG,IAAhB;AACD;;AAJgC,CAAnC;AAOA,MAAMK,SAAS,GAAG;AAChBC,EAAAA,GAAG,EAAE,SADW;AAEhBC,EAAAA,KAAK,EAAE,SAFS;AAGhBC,EAAAA,IAAI,EAAE;AAHU,CAAlB;AAKA,MAAMC,SAAS,GAAG;AAChBC,EAAAA,IAAI,EAAE,SADU;AAEhBC,EAAAA,MAAM,EAAE;AAFQ,CAAlB;;AAKA,MAAMC,YAAY,GAAG,CAACC,OAAD,EAAUC,OAAV,KAAsBb,IAAI,CAACC,cAAL,CAAoBW,OAApB,EAA6BC,OAA7B,EAAsCC,MAAjF;AACA;AACA;AACA;AACA;;;AAGA,MAAMC,iBAAN,CAAwB;AACtBC,EAAAA,WAAW,GAGH;AAAA,QAHI;AACVJ,MAAAA,OAAO,GAAGV,SADA;AAEVe,MAAAA,WAAW,GAAG;AAFJ,KAGJ,uEAAJ,EAAI;AACN,SAAKL,OAAL,GAAeA,OAAf;;AAEA,SAAKK,WAAL,GAAmB,MAAMA,WAAzB;;AAEA,aAASC,eAAT,CAAyBC,IAAzB,EAA+BL,MAA/B,EAAuC;AACrC,aAAO,OAAOA,MAAP,KAAkB,UAAlB,GAA+BA,MAAM,CAACK,IAAD,EAAOP,OAAP,CAArC,GAAuDO,IAAI,CAACC,cAAL,CAAoBR,OAApB,EAA6BE,MAA7B,CAA9D;AACD;;AAED,UAAMO,OAAO,GAAG;AACdF,MAAAA,IAAI,EAAER,YAAY,CAACC,OAAD,EAAU;AAC5Bb,MAAAA,aAAa,GAAG;AACdI,QAAAA,SAAS,EAAE;AADG,OAAH,GAETC,SAHc,CADJ;AAKdkB,MAAAA,IAAI,EAAEX,YAAY,CAACC,OAAD,EAAU;AAC5Bb,MAAAA,aAAa,GAAG;AACdwB,QAAAA,SAAS,EAAE;AADG,OAAH,GAETf,SAHc,CALJ;AASdgB,MAAAA,QAAQ,EAAEb,YAAY,CAACC,OAAD,EAAU;AAChCb,MAAAA,aAAa,GAAG;AACdI,QAAAA,SAAS,EAAE,OADG;AAEdoB,QAAAA,SAAS,EAAE;AAFG,OAAH,GAGTE,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBtB,SAAlB,EAA6BI,SAA7B,CAJkB,CATR;AAcdmB,MAAAA,MAAM,EAAEhB,YAAY,CAACC,OAAD,EAAU;AAC5BN,QAAAA,KAAK,EAAE,OADqB;AAE5BC,QAAAA,IAAI,EAAE;AAFsB,OAAV,CAdN;AAkBdqB,MAAAA,OAAO,EAAEjB,YAAY,CAACC,OAAD,EAAU;AAC7BgB,QAAAA,OAAO,EAAE;AADoB,OAAV,CAlBP;AAqBdC,MAAAA,UAAU,EAAElB,YAAY,CAACC,OAAD,EAAU;AAChCP,QAAAA,GAAG,EAAE;AAD2B,OAAV,CArBV;AAwBdC,MAAAA,KAAK,EAAEK,YAAY,CAACC,OAAD,EAAU;AAC3BN,QAAAA,KAAK,EAAE;AADoB,OAAV,CAxBL;AA2BdC,MAAAA,IAAI,EAAEI,YAAY,CAACC,OAAD,EAAU;AAC1BL,QAAAA,IAAI,EAAE;AADoB,OAAV,CA3BJ;AA8BduB,MAAAA,MAAM,EAAEX,IAAI,IAAK,GAAE,KAAKZ,IAAL,CAAUY,IAAV,CAAgB,MAAK,KAAKZ,IAAL,CAAUT,KAAK,CAACiC,KAAN,CAAYZ,IAAZ,EAAkB,QAAlB,CAAV,CAAuC,EA9BjE;AA+Bda,MAAAA,OAAO,EAAEb,IAAI,IAAK,GAAE,KAAKZ,IAAL,CAAUY,IAAV,CAAgB,MAAK,KAAKZ,IAAL,CAAUT,KAAK,CAACiC,KAAN,CAAYZ,IAAZ,EAAkB,SAAlB,CAAV,CAAwC;AA/BnE,KAAhB;AAiCAM,IAAAA,MAAM,CAACQ,IAAP,CAAYZ,OAAZ,EAAqBa,OAArB,CAA6BC,GAAG,IAAI;AAClC,WAAKA,GAAL,IAAY,CAAChB,IAAD,EAAOL,MAAP,KAAkBA,MAAM,GAAGI,eAAe,CAACC,IAAD,EAAOL,MAAP,CAAlB,GAAmCO,OAAO,CAACc,GAAD,CAAP,CAAahB,IAAb,CAAvE;AACD,KAFD;AAGD;;AAEDiB,EAAAA,gBAAgB,CAACjB,IAAD,EAGb;AAAA,QAHoBL,MAGpB,uEAH6B;AAC9BX,MAAAA,SAAS,EAAE,OADmB;AAE9BoB,MAAAA,SAAS,EAAE;AAFmB,KAG7B;AACD,WAAOvB,IAAI,CAACC,cAAL,CAAoB,KAAKW,OAAzB,EAAkCE,MAAlC,EAA0CuB,aAA1C,CAAwDlB,IAAxD,EAA8DmB,MAA9D,CAAqEC,CAAC,IAAIA,CAAC,CAACC,IAAF,KAAW,cAArF,CAAP;AACD;;AAEDC,EAAAA,KAAK,CAACC,KAAD,EAAQ;AACX,UAAMvB,IAAI,GAAG,IAAIwB,IAAJ,CAASD,KAAT,CAAb;AACA,WAAOE,KAAK,CAAC,CAACzB,IAAF,CAAL,GAAe,IAAf,GAAsBA,IAA7B;AACD;;AA7DqB;AAiExB;AACA;AACA;;;AACA,MAAM0B,mBAAN,CAA0B;AACxB7B,EAAAA,WAAW,GAEH;AAAA,QAFI;AACVJ,MAAAA,OAAO,GAAGV;AADA,KAEJ,uEAAJ,EAAI;;AACN,QAAI4C,kBAAJ;;AAEA,SAAKlC,OAAL,GAAeA,OAAf;AACA,UAAMmC,OAAO,GAAG,mBAAmB/C,IAAI,CAACgD,YAAL,CAAkBpC,OAAlB,CAAnB,GAAgDZ,IAAI,CAACgD,YAAL,CAAkBpC,OAAlB,EAA2ByB,aAA3B,CAAyC,GAAzC,EAA8C,CAA9C,EAAiDK,KAAjG,GAAyG,CAAC,CAACI,kBAAkB,GAAG,IAAI1B,cAAJ,CAAmBR,OAAnB,EAA4BqC,KAA5B,CAAkC,OAAlC,CAAtB,KAAqE,IAArE,GAA4E,KAAK,CAAjF,GAAqFH,kBAAkB,CAAC,CAAD,CAAxG,KAAgH,GAAzO;AACA,UAAMI,SAAS,GAAGlD,IAAI,CAACgD,YAAL,CAAkBpC,OAAlB,EAA2BE,MAA7C;;AAEA,SAAKqC,gBAAL,GAAwB,MAAMJ,OAA9B;;AAEA,SAAKjC,MAAL,GAAc,CAACsC,GAAD,EAAMtC,MAAN,KAAiB;AAC7B,UAAIA,MAAJ,EAAY;AACV,eAAO,OAAOA,MAAP,KAAkB,UAAlB,GAA+BA,MAAM,CAACsC,GAAD,EAAMxC,OAAN,CAArC,GAAsDwC,GAAG,CAAChC,cAAJ,CAAmBR,OAAnB,EAA4BE,MAA5B,CAA7D;AACD;;AAED,aAAOoC,SAAS,CAACE,GAAD,CAAhB;AACD,KAND;AAOD;;AAEDX,EAAAA,KAAK,CAACC,KAAD,EAAQ;AACX,WAAOW,UAAU,CAACX,KAAK,CAACY,OAAN,CAAc,KAAKH,gBAAL,EAAd,EAAuC,GAAvC,CAAD,CAAjB;AACD;;AAvBuB;;AA2B1B,SAASpC,iBAAiB,IAAIwC,aAA9B,EAA6CV,mBAAmB,IAAIW,eAApE","sourcesContent":["import dates from './dates';\n// assumes both are supported or none\nlet supportStyles = false;\nnew Intl.DateTimeFormat(undefined, {\n  // @ts-ignore\n  get dateStyle() {\n    supportStyles = true;\n  }\n\n});\nconst dateShort = {\n  day: 'numeric',\n  month: 'numeric',\n  year: 'numeric'\n};\nconst timeShort = {\n  hour: 'numeric',\n  minute: 'numeric'\n};\n\nconst getFormatter = (culture, options) => Intl.DateTimeFormat(culture, options).format;\n/**\n * A `react-widgets` Localizer using native `Intl` APIs.\n *\n */\n\n\nclass IntlDateLocalizer {\n  constructor({\n    culture = undefined,\n    firstOfWeek = 0\n  } = {}) {\n    this.culture = culture;\n\n    this.firstOfWeek = () => firstOfWeek;\n\n    function normalizeFormat(date, format) {\n      return typeof format === 'function' ? format(date, culture) : date.toLocaleString(culture, format);\n    }\n\n    const formats = {\n      date: getFormatter(culture, // @ts-ignore\n      supportStyles ? {\n        dateStyle: 'short'\n      } : dateShort),\n      time: getFormatter(culture, // @ts-ignore\n      supportStyles ? {\n        timeStyle: 'short'\n      } : timeShort),\n      datetime: getFormatter(culture, // @ts-ignore\n      supportStyles ? {\n        dateStyle: 'short',\n        timeStyle: 'short'\n      } : Object.assign({}, dateShort, timeShort)),\n      header: getFormatter(culture, {\n        month: 'short',\n        year: 'numeric'\n      }),\n      weekday: getFormatter(culture, {\n        weekday: 'narrow'\n      }),\n      dayOfMonth: getFormatter(culture, {\n        day: '2-digit'\n      }),\n      month: getFormatter(culture, {\n        month: 'short'\n      }),\n      year: getFormatter(culture, {\n        year: 'numeric'\n      }),\n      decade: date => `${this.year(date)} - ${this.year(dates.endOf(date, 'decade'))}`,\n      century: date => `${this.year(date)} - ${this.year(dates.endOf(date, 'century'))}`\n    };\n    Object.keys(formats).forEach(key => {\n      this[key] = (date, format) => format ? normalizeFormat(date, format) : formats[key](date);\n    });\n  }\n\n  toFormattedParts(date, format = {\n    dateStyle: 'short',\n    timeStyle: 'short'\n  }) {\n    return Intl.DateTimeFormat(this.culture, format).formatToParts(date).filter(p => p.type !== 'timeZoneName');\n  }\n\n  parse(value) {\n    const date = new Date(value);\n    return isNaN(+date) ? null : date;\n  }\n\n}\n\n/**\n * A number localization strategy based on `Intl.NumberFormat`.\n */\nclass IntlNumberLocalizer {\n  constructor({\n    culture = undefined\n  } = {}) {\n    var _$toLocaleString$m;\n\n    this.culture = culture;\n    const decimal = 'formatToParts' in Intl.NumberFormat(culture) ? Intl.NumberFormat(culture).formatToParts(1.1)[1].value : ((_$toLocaleString$m = 1.1.toLocaleString(culture).match(/[^\\d]/)) == null ? void 0 : _$toLocaleString$m[0]) || '.';\n    const formatter = Intl.NumberFormat(culture).format;\n\n    this.decimalCharacter = () => decimal;\n\n    this.format = (num, format) => {\n      if (format) {\n        return typeof format === 'function' ? format(num, culture) : num.toLocaleString(culture, format);\n      }\n\n      return formatter(num);\n    };\n  }\n\n  parse(value) {\n    return parseFloat(value.replace(this.decimalCharacter(), '.'));\n  }\n\n}\n\nexport { IntlDateLocalizer as DateLocalizer, IntlNumberLocalizer as NumberLocalizer };"]},"metadata":{},"sourceType":"module"}