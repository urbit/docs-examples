{"version":3,"file":"urbit-http-api.min.js","sources":["../src/types.ts","../node_modules/browser-or-node/lib/index.js","../node_modules/@microsoft/fetch-event-source/lib/esm/parse.js","../node_modules/@microsoft/fetch-event-source/lib/esm/fetch.js","../src/utils.ts","../src/Urbit.ts"],"sourcesContent":["/**\n * An urbit style path, rendered as a Javascript string\n * @example\n * `\"/updates\"`\n */\nexport type Path = string;\n\n/**\n * @p including leading sig, rendered as a string\n *\n * @example\n * ```typescript\n * \"~sampel-palnet\"\n * ```\n *\n */\nexport type Patp = string;\n\n/**\n * @p not including leading sig, rendered as a string\n *\n * @example\n * ```typescript\n * \"sampel-palnet\"\n * ```\n *\n */\nexport type PatpNoSig = string;\n\n/**\n * The name of a clay mark, as a string\n *\n * @example\n * ```typescript\n * \"graph-update\"\n * ```\n */\nexport type Mark = string;\n\n/**\n * The name of a gall agent, as a string\n *\n * @example\n *\n * ```typescript\n * \"graph-store\"\n * ```\n */\nexport type GallAgent = string;\n\n/**\n * Description of an outgoing poke\n *\n * @typeParam Action - Typescript type of the data being poked\n */\nexport interface Poke<Action> {\n  /**\n   * Ship to poke. If left empty, the api lib will populate it with the ship that it is connected to.\n   *\n   * @remarks\n   *\n   * This should always be the ship that you are connected to\n   *\n   */\n  ship?: PatpNoSig;\n  /**\n   */\n  app: GallAgent;\n  /**\n   * Mark of the cage to be poked\n   *\n   */\n  mark: Mark;\n  /**\n   * Vase of the cage of to be poked, as JSON\n   */\n  json: Action;\n}\n\n/**\n * Description of a scry request\n */\nexport interface Scry {\n  /** {@inheritDoc GallAgent} */\n  app: GallAgent;\n  /** {@inheritDoc Path} */\n  path: Path;\n}\n\n/**\n * Description of a thread request\n *\n * @typeParam Action - Typescript type of the data being poked\n */\nexport interface Thread<Action> {\n  /**\n   * The mark of the input vase\n   */\n  inputMark: Mark;\n  /**\n   * The mark of the output vase\n   */\n  outputMark: Mark;\n  /**\n   * Name of the thread\n   *\n   * @example\n   * ```typescript\n   * \"graph-add-nodes\"\n   * ```\n   */\n  threadName: string;\n  /**\n   * Desk of thread\n   */\n  desk?: string;\n  /**\n   * Data of the input vase\n   */\n  body: Action;\n}\n\nexport type Action = 'poke' | 'subscribe' | 'ack' | 'unsubscribe' | 'delete';\n\nexport interface PokeHandlers {\n  onSuccess?: () => void;\n  onError?: (e: any) => void;\n}\n\nexport type PokeInterface<T> = PokeHandlers & Poke<T>;\n\nexport interface AuthenticationInterface {\n  ship: string;\n  url: string;\n  code: string;\n  verbose?: boolean;\n}\n\n/**\n * Subscription event handlers\n *\n */\nexport interface SubscriptionInterface {\n  /**\n   * Handle negative %watch-ack\n   */\n  err?(error: any, id: string): void;\n  /**\n   * Handle %fact\n   */\n  event?(data: any): void;\n  /**\n   * Handle %kick\n   */\n  quit?(data: any): void;\n}\n\nexport type OnceSubscriptionErr = 'quit' | 'nack' | 'timeout';\n\nexport interface SubscriptionRequestInterface extends SubscriptionInterface {\n  /**\n   * The app to subscribe to\n   * @example\n   * `\"graph-store\"`\n   */\n  app: GallAgent;\n  /**\n   * The path to which to subscribe\n   * @example\n   * `\"/keys\"`\n   */\n  path: Path;\n}\n\nexport interface headers {\n  'Content-Type': string;\n  Cookie?: string;\n}\n\nexport interface CustomEventHandler {\n  (data: any, response: string): void;\n}\n\nexport interface SSEOptions {\n  headers?: {\n    Cookie?: string;\n  };\n  withCredentials?: boolean;\n}\n\nexport interface Message extends Record<string, any> {\n  action: Action;\n  id?: number;\n}\n\nexport class ResumableError extends Error {}\n\nexport class FatalError extends Error {}\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/* global window self */\n\nvar isBrowser = typeof window !== 'undefined' && typeof window.document !== 'undefined';\n\n/* eslint-disable no-restricted-globals */\nvar isWebWorker = (typeof self === 'undefined' ? 'undefined' : _typeof(self)) === 'object' && self.constructor && self.constructor.name === 'DedicatedWorkerGlobalScope';\n/* eslint-enable no-restricted-globals */\n\nvar isNode = typeof process !== 'undefined' && process.versions != null && process.versions.node != null;\n\n/**\n * @see https://github.com/jsdom/jsdom/releases/tag/12.0.0\n * @see https://github.com/jsdom/jsdom/issues/1537\n */\n/* eslint-disable no-undef */\nvar isJsDom = function isJsDom() {\n  return typeof window !== 'undefined' && window.name === 'nodejs' || navigator.userAgent.includes('Node.js') || navigator.userAgent.includes('jsdom');\n};\n\nexports.isBrowser = isBrowser;\nexports.isWebWorker = isWebWorker;\nexports.isNode = isNode;\nexports.isJsDom = isJsDom;","export async function getBytes(stream, onChunk) {\r\n    const reader = stream.getReader();\r\n    let result;\r\n    while (!(result = await reader.read()).done) {\r\n        onChunk(result.value);\r\n    }\r\n}\r\nexport function getLines(onLine) {\r\n    let buffer;\r\n    let position;\r\n    let fieldLength;\r\n    let discardTrailingNewline = false;\r\n    return function onChunk(arr) {\r\n        if (buffer === undefined) {\r\n            buffer = arr;\r\n            position = 0;\r\n            fieldLength = -1;\r\n        }\r\n        else {\r\n            buffer = concat(buffer, arr);\r\n        }\r\n        const bufLength = buffer.length;\r\n        let lineStart = 0;\r\n        while (position < bufLength) {\r\n            if (discardTrailingNewline) {\r\n                if (buffer[position] === 10) {\r\n                    lineStart = ++position;\r\n                }\r\n                discardTrailingNewline = false;\r\n            }\r\n            let lineEnd = -1;\r\n            for (; position < bufLength && lineEnd === -1; ++position) {\r\n                switch (buffer[position]) {\r\n                    case 58:\r\n                        if (fieldLength === -1) {\r\n                            fieldLength = position - lineStart;\r\n                        }\r\n                        break;\r\n                    case 13:\r\n                        discardTrailingNewline = true;\r\n                    case 10:\r\n                        lineEnd = position;\r\n                        break;\r\n                }\r\n            }\r\n            if (lineEnd === -1) {\r\n                break;\r\n            }\r\n            onLine(buffer.subarray(lineStart, lineEnd), fieldLength);\r\n            lineStart = position;\r\n            fieldLength = -1;\r\n        }\r\n        if (lineStart === bufLength) {\r\n            buffer = undefined;\r\n        }\r\n        else if (lineStart !== 0) {\r\n            buffer = buffer.subarray(lineStart);\r\n            position -= lineStart;\r\n        }\r\n    };\r\n}\r\nexport function getMessages(onId, onRetry, onMessage) {\r\n    let message = newMessage();\r\n    const decoder = new TextDecoder();\r\n    return function onLine(line, fieldLength) {\r\n        if (line.length === 0) {\r\n            onMessage === null || onMessage === void 0 ? void 0 : onMessage(message);\r\n            message = newMessage();\r\n        }\r\n        else if (fieldLength > 0) {\r\n            const field = decoder.decode(line.subarray(0, fieldLength));\r\n            const valueOffset = fieldLength + (line[fieldLength + 1] === 32 ? 2 : 1);\r\n            const value = decoder.decode(line.subarray(valueOffset));\r\n            switch (field) {\r\n                case 'data':\r\n                    message.data = message.data\r\n                        ? message.data + '\\n' + value\r\n                        : value;\r\n                    break;\r\n                case 'event':\r\n                    message.event = value;\r\n                    break;\r\n                case 'id':\r\n                    onId(message.id = value);\r\n                    break;\r\n                case 'retry':\r\n                    const retry = parseInt(value, 10);\r\n                    if (!isNaN(retry)) {\r\n                        onRetry(message.retry = retry);\r\n                    }\r\n                    break;\r\n            }\r\n        }\r\n    };\r\n}\r\nfunction concat(a, b) {\r\n    const res = new Uint8Array(a.length + b.length);\r\n    res.set(a);\r\n    res.set(b, a.length);\r\n    return res;\r\n}\r\nfunction newMessage() {\r\n    return {\r\n        data: '',\r\n        event: '',\r\n        id: '',\r\n        retry: undefined,\r\n    };\r\n}\r\n//# sourceMappingURL=parse.js.map","var __rest = (this && this.__rest) || function (s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n};\r\nimport { getBytes, getLines, getMessages } from './parse';\r\nexport const EventStreamContentType = 'text/event-stream';\r\nconst DefaultRetryInterval = 1000;\r\nconst LastEventId = 'last-event-id';\r\nexport function fetchEventSource(input, _a) {\r\n    var { signal: inputSignal, headers: inputHeaders, onopen: inputOnOpen, onmessage, onclose, onerror, openWhenHidden, fetch: inputFetch } = _a, rest = __rest(_a, [\"signal\", \"headers\", \"onopen\", \"onmessage\", \"onclose\", \"onerror\", \"openWhenHidden\", \"fetch\"]);\r\n    return new Promise((resolve, reject) => {\r\n        const headers = Object.assign({}, inputHeaders);\r\n        if (!headers.accept) {\r\n            headers.accept = EventStreamContentType;\r\n        }\r\n        let curRequestController;\r\n        function onVisibilityChange() {\r\n            curRequestController.abort();\r\n            if (!document.hidden) {\r\n                create();\r\n            }\r\n        }\r\n        if (!openWhenHidden) {\r\n            document.addEventListener('visibilitychange', onVisibilityChange);\r\n        }\r\n        let retryInterval = DefaultRetryInterval;\r\n        let retryTimer = 0;\r\n        function dispose() {\r\n            document.removeEventListener('visibilitychange', onVisibilityChange);\r\n            window.clearTimeout(retryTimer);\r\n            curRequestController.abort();\r\n        }\r\n        inputSignal === null || inputSignal === void 0 ? void 0 : inputSignal.addEventListener('abort', () => {\r\n            dispose();\r\n            resolve();\r\n        });\r\n        const fetch = inputFetch !== null && inputFetch !== void 0 ? inputFetch : window.fetch;\r\n        const onopen = inputOnOpen !== null && inputOnOpen !== void 0 ? inputOnOpen : defaultOnOpen;\r\n        async function create() {\r\n            var _a;\r\n            curRequestController = new AbortController();\r\n            try {\r\n                const response = await fetch(input, Object.assign(Object.assign({}, rest), { headers, signal: curRequestController.signal }));\r\n                await onopen(response);\r\n                await getBytes(response.body, getLines(getMessages(id => {\r\n                    if (id) {\r\n                        headers[LastEventId] = id;\r\n                    }\r\n                    else {\r\n                        delete headers[LastEventId];\r\n                    }\r\n                }, retry => {\r\n                    retryInterval = retry;\r\n                }, onmessage)));\r\n                onclose === null || onclose === void 0 ? void 0 : onclose();\r\n                dispose();\r\n                resolve();\r\n            }\r\n            catch (err) {\r\n                if (!curRequestController.signal.aborted) {\r\n                    try {\r\n                        const interval = (_a = onerror === null || onerror === void 0 ? void 0 : onerror(err)) !== null && _a !== void 0 ? _a : retryInterval;\r\n                        window.clearTimeout(retryTimer);\r\n                        retryTimer = window.setTimeout(create, interval);\r\n                    }\r\n                    catch (innerErr) {\r\n                        dispose();\r\n                        reject(innerErr);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        create();\r\n    });\r\n}\r\nfunction defaultOnOpen(response) {\r\n    const contentType = response.headers.get('content-type');\r\n    if (!(contentType === null || contentType === void 0 ? void 0 : contentType.startsWith(EventStreamContentType))) {\r\n        throw new Error(`Expected content-type to be ${EventStreamContentType}, Actual: ${contentType}`);\r\n    }\r\n}\r\n//# sourceMappingURL=fetch.js.map","export function camelize(str: string) {\n  return str\n    .replace(/\\s(.)/g, function ($1: string) {\n      return $1.toUpperCase();\n    })\n    .replace(/\\s/g, '')\n    .replace(/^(.)/, function ($1: string) {\n      return $1.toLowerCase();\n    });\n}\n\nexport function uncamelize(str: string, separator = '-') {\n  // Replace all capital letters by separator followed by lowercase one\n  var str = str.replace(/[A-Z]/g, function (letter: string) {\n    return separator + letter.toLowerCase();\n  });\n  return str.replace(new RegExp('^' + separator), '');\n}\n\n/**\n * Returns a hex string of given length.\n *\n * Poached from StackOverflow.\n *\n * @param len Length of hex string to return.\n */\nexport function hexString(len: number): string {\n  const maxlen = 8;\n  const min = Math.pow(16, Math.min(len, maxlen) - 1);\n  const max = Math.pow(16, Math.min(len, maxlen)) - 1;\n  const n = Math.floor(Math.random() * (max - min + 1)) + min;\n  let r = n.toString(16);\n  while (r.length < len) {\n    r = r + hexString(len - maxlen);\n  }\n  return r;\n}\n\n/**\n * Generates a random UID.\n *\n * Copied from https://github.com/urbit/urbit/blob/137e4428f617c13f28ed31e520eff98d251ed3e9/pkg/interface/src/lib/util.js#L3\n */\nexport function uid(): string {\n  let str = '0v';\n  str += Math.ceil(Math.random() * 8) + '.';\n  for (let i = 0; i < 5; i++) {\n    let _str = Math.ceil(Math.random() * 10000000).toString(32);\n    _str = ('00000' + _str).substr(-5, 5);\n    str += _str + '.';\n  }\n  return str.slice(0, -1);\n}\n","import { isBrowser, isNode } from 'browser-or-node';\nimport {\n  fetchEventSource,\n  EventSourceMessage,\n} from '@microsoft/fetch-event-source';\n\nimport {\n  Scry,\n  Thread,\n  AuthenticationInterface,\n  PokeInterface,\n  SubscriptionRequestInterface,\n  headers,\n  SSEOptions,\n  PokeHandlers,\n  Message,\n} from './types';\nimport { hexString } from './utils';\n\n/**\n * A class for interacting with an urbit ship, given its URL and code\n */\nexport class Urbit {\n  /**\n   * UID will be used for the channel: The current unix time plus a random hex string\n   */\n  private uid: string = `${Math.floor(Date.now() / 1000)}-${hexString(6)}`;\n\n  /**\n   * Last Event ID is an auto-updated index of which events have been sent over this channel\n   */\n  private lastEventId: number = 0;\n\n  private lastAcknowledgedEventId: number = 0;\n\n  /**\n   * SSE Client is null for now; we don't want to start polling until it the channel exists\n   */\n  private sseClientInitialized: boolean = false;\n\n  /**\n   * Cookie gets set when we log in.\n   */\n  cookie?: string | undefined;\n\n  /**\n   * A registry of requestId to successFunc/failureFunc\n   *\n   * These functions are registered during a +poke and are executed\n   * in the onServerEvent()/onServerError() callbacks. Only one of\n   * the functions will be called, and the outstanding poke will be\n   * removed after calling the success or failure function.\n   */\n\n  private outstandingPokes: Map<number, PokeHandlers> = new Map();\n\n  /**\n   * A registry of requestId to subscription functions.\n   *\n   * These functions are registered during a +subscribe and are\n   * executed in the onServerEvent()/onServerError() callbacks. The\n   * event function will be called whenever a new piece of data on this\n   * subscription is available, which may be 0, 1, or many times. The\n   * disconnect function may be called exactly once.\n   */\n  private outstandingSubscriptions: Map<number, SubscriptionRequestInterface> =\n    new Map();\n\n  /**\n   * Our abort controller, used to close the connection\n   */\n  private abort = new AbortController();\n\n  /**\n   * Ship can be set, in which case we can do some magic stuff like send chats\n   */\n  ship?: string | null;\n\n  /**\n   * If verbose, logs output eagerly.\n   */\n  verbose?: boolean;\n\n  /**\n   * number of consecutive errors in connecting to the eventsource\n   */\n  private errorCount = 0;\n\n  onError?: (error: any) => void = null;\n\n  onRetry?: () => void = null;\n\n  onOpen?: () => void = null;\n\n  /** This is basic interpolation to get the channel URL of an instantiated Urbit connection. */\n  private get channelUrl(): string {\n    return `${this.url}/~/channel/${this.uid}`;\n  }\n\n  private get fetchOptions(): any {\n    const headers: headers = {\n      'Content-Type': 'application/json',\n    };\n    if (!isBrowser) {\n      headers.Cookie = this.cookie;\n    }\n    return {\n      credentials: 'include',\n      accept: '*',\n      headers,\n      signal: this.abort.signal,\n    };\n  }\n\n  /**\n   * Constructs a new Urbit connection.\n   *\n   * @param url  The URL (with protocol and port) of the ship to be accessed. If\n   * the airlock is running in a webpage served by the ship, this should just\n   * be the empty string.\n   * @param code The access code for the ship at that address\n   */\n  constructor(public url: string, public code?: string, public desk?: string) {\n    if (isBrowser) {\n      window.addEventListener('beforeunload', this.delete);\n    }\n    return this;\n  }\n\n  /**\n   * All-in-one hook-me-up.\n   *\n   * Given a ship, url, and code, this returns an airlock connection\n   * that is ready to go. It `|hi`s itself to create the channel,\n   * then opens the channel via EventSource.\n   *\n   */\n  static async authenticate({\n    ship,\n    url,\n    code,\n    verbose = false,\n  }: AuthenticationInterface) {\n    const airlock = new Urbit(`http://${url}`, code);\n    airlock.verbose = verbose;\n    airlock.ship = ship;\n    await airlock.connect();\n    await airlock.poke({\n      app: 'hood',\n      mark: 'helm-hi',\n      json: 'opening airlock',\n    });\n    await airlock.eventSource();\n    return airlock;\n  }\n\n  /**\n   * Connects to the Urbit ship. Nothing can be done until this is called.\n   * That's why we roll it into this.authenticate\n   */\n  async connect(): Promise<void> {\n    if (this.verbose) {\n      console.log(\n        `password=${this.code} `,\n        isBrowser\n          ? 'Connecting in browser context at ' + `${this.url}/~/login`\n          : 'Connecting from node context'\n      );\n    }\n    return fetch(`${this.url}/~/login`, {\n      method: 'post',\n      body: `password=${this.code}`,\n      credentials: 'include',\n    }).then((response) => {\n      if (this.verbose) {\n        console.log('Received authentication response', response);\n      }\n      const cookie = response.headers.get('set-cookie');\n      if (!this.ship) {\n        this.ship = new RegExp(/urbauth-~([\\w-]+)/).exec(cookie)[1];\n      }\n      if (!isBrowser) {\n        this.cookie = cookie;\n      }\n    });\n  }\n\n  /**\n   * Initializes the SSE pipe for the appropriate channel.\n   */\n  async eventSource(): Promise<void> {\n    if (this.sseClientInitialized) {\n      return Promise.resolve();\n    }\n    if (this.lastEventId === 0) {\n      // Can't receive events until the channel is open,\n      // so poke and open then\n      await this.poke({\n        app: 'hood',\n        mark: 'helm-hi',\n        json: 'Opening API channel',\n      });\n      return;\n    }\n    this.sseClientInitialized = true;\n    return new Promise((resolve, reject) => {\n      const sseOptions: SSEOptions = {\n        headers: {},\n      };\n      if (isBrowser) {\n        sseOptions.withCredentials = true;\n      } else if (isNode) {\n        sseOptions.headers.Cookie = this.cookie;\n      }\n      fetchEventSource(this.channelUrl, {\n        ...this.fetchOptions,\n        openWhenHidden: true,\n        onopen: async (response) => {\n          if (this.verbose) {\n            console.log('Opened eventsource', response);\n          }\n          if (response.ok) {\n            this.errorCount = 0;\n            this.onOpen && this.onOpen();\n            resolve();\n            return; // everything's good\n          } else {\n            const err = new Error('failed to open eventsource');\n            reject(err);\n          }\n        },\n        onmessage: (event: EventSourceMessage) => {\n          if (this.verbose) {\n            console.log('Received SSE: ', event);\n          }\n          if (!event.id) return;\n          this.lastEventId = parseInt(event.id, 10);\n          if (this.lastEventId - this.lastAcknowledgedEventId > 20) {\n            this.ack(this.lastEventId);\n          }\n\n          if (event.data && JSON.parse(event.data)) {\n            const data: any = JSON.parse(event.data);\n\n            if (\n              data.response === 'poke' &&\n              this.outstandingPokes.has(data.id)\n            ) {\n              const funcs = this.outstandingPokes.get(data.id);\n              if (data.hasOwnProperty('ok')) {\n                funcs.onSuccess();\n              } else if (data.hasOwnProperty('err')) {\n                console.error(data.err);\n                funcs.onError(data.err);\n              } else {\n                console.error('Invalid poke response', data);\n              }\n              this.outstandingPokes.delete(data.id);\n            } else if (\n              data.response === 'subscribe' &&\n              this.outstandingSubscriptions.has(data.id)\n            ) {\n              const funcs = this.outstandingSubscriptions.get(data.id);\n              if (data.hasOwnProperty('err')) {\n                console.error(data.err);\n                funcs.err(data.err, data.id);\n                this.outstandingSubscriptions.delete(data.id);\n              }\n            } else if (\n              data.response === 'diff' &&\n              this.outstandingSubscriptions.has(data.id)\n            ) {\n              const funcs = this.outstandingSubscriptions.get(data.id);\n              try {\n                funcs.event(data.json);\n              } catch (e) {\n                console.error('Failed to call subscription event callback', e);\n              }\n            } else if (\n              data.response === 'quit' &&\n              this.outstandingSubscriptions.has(data.id)\n            ) {\n              const funcs = this.outstandingSubscriptions.get(data.id);\n              funcs.quit(data);\n              this.outstandingSubscriptions.delete(data.id);\n            } else {\n              console.log([...this.outstandingSubscriptions.keys()]);\n              console.log('Unrecognized response', data);\n            }\n          }\n        },\n        onerror: (error) => {\n          console.warn(error);\n          if (this.errorCount++ < 4) {\n            this.onRetry && this.onRetry();\n            return Math.pow(2, this.errorCount - 1) * 750;\n          }\n          this.onError && this.onError(error);\n          throw error;\n        },\n        onclose: () => {\n          console.log('e');\n          throw new Error('Ship unexpectedly closed the connection');\n        },\n      });\n    });\n  }\n\n  /**\n   * Reset airlock, abandoning current subscriptions and wiping state\n   *\n   */\n  reset() {\n    this.delete();\n    this.abort.abort();\n    this.abort = new AbortController();\n    this.uid = `${Math.floor(Date.now() / 1000)}-${hexString(6)}`;\n    this.lastEventId = 0;\n    this.lastAcknowledgedEventId = 0;\n    this.outstandingSubscriptions = new Map();\n    this.outstandingPokes = new Map();\n    this.sseClientInitialized = false;\n  }\n\n  /**\n   * Autoincrements the next event ID for the appropriate channel.\n   */\n  private getEventId(): number {\n    this.lastEventId = Number(this.lastEventId) + 1;\n    return this.lastEventId;\n  }\n\n  /**\n   * Acknowledges an event.\n   *\n   * @param eventId The event to acknowledge.\n   */\n  private async ack(eventId: number): Promise<number | void> {\n    this.lastAcknowledgedEventId = eventId;\n    const message: Message = {\n      action: 'ack',\n      'event-id': eventId,\n    };\n    await this.sendJSONtoChannel(message);\n    return eventId;\n  }\n\n  private async sendJSONtoChannel(...json: Message[]): Promise<void> {\n    const response = await fetch(this.channelUrl, {\n      ...this.fetchOptions,\n      method: 'PUT',\n      body: JSON.stringify(json),\n    });\n    if (!response.ok) {\n      throw new Error('Failed to PUT channel');\n    }\n    if (!this.sseClientInitialized) {\n      await this.eventSource();\n    }\n  }\n\n  /**\n   * Creates a subscription, waits for a fact and then unsubscribes\n   *\n   * @param app Name of gall agent to subscribe to\n   * @param path Path to subscribe to\n   * @param timeout Optional timeout before ending subscription\n   *\n   * @returns The first fact on the subcription\n   */\n  async subscribeOnce<T = any>(app: string, path: string, timeout?: number) {\n    return new Promise<T>(async (resolve, reject) => {\n      let done = false;\n      let id: number | null = null;\n      const quit = () => {\n        if (!done) {\n          reject('quit');\n        }\n      };\n      const event = (e: T) => {\n        if (!done) {\n          resolve(e);\n          this.unsubscribe(id);\n        }\n      };\n      const request = { app, path, event, err: reject, quit };\n\n      id = await this.subscribe(request);\n\n      if (timeout) {\n        setTimeout(() => {\n          if (!done) {\n            done = true;\n            reject('timeout');\n            this.unsubscribe(id);\n          }\n        }, timeout);\n      }\n    });\n  }\n\n  /**\n   * Pokes a ship with data.\n   *\n   * @param app The app to poke\n   * @param mark The mark of the data being sent\n   * @param json The data to send\n   */\n  async poke<T>(params: PokeInterface<T>): Promise<number> {\n    const { app, mark, json, ship, onSuccess, onError } = {\n      onSuccess: () => {},\n      onError: () => {},\n      ship: this.ship,\n      ...params,\n    };\n    const message: Message = {\n      id: this.getEventId(),\n      action: 'poke',\n      ship,\n      app,\n      mark,\n      json,\n    };\n    const [send, result] = await Promise.all([\n      this.sendJSONtoChannel(message),\n      new Promise<number>((resolve, reject) => {\n        this.outstandingPokes.set(message.id, {\n          onSuccess: () => {\n            onSuccess();\n            resolve(message.id);\n          },\n          onError: (event) => {\n            onError(event);\n            reject(event.err);\n          },\n        });\n      }),\n    ]);\n    return result;\n  }\n\n  /**\n   * Subscribes to a path on an app on a ship.\n   *\n   *\n   * @param app The app to subsribe to\n   * @param path The path to which to subscribe\n   * @param handlers Handlers to deal with various events of the subscription\n   */\n  async subscribe(params: SubscriptionRequestInterface): Promise<number> {\n    const { app, path, ship, err, event, quit } = {\n      err: () => {},\n      event: () => {},\n      quit: () => {},\n      ship: this.ship,\n      ...params,\n    };\n\n    const message: Message = {\n      id: this.getEventId(),\n      action: 'subscribe',\n      ship,\n      app,\n      path,\n    };\n\n    this.outstandingSubscriptions.set(message.id, {\n      app,\n      path,\n      err,\n      event,\n      quit,\n    });\n\n    await this.sendJSONtoChannel(message);\n\n    return message.id;\n  }\n\n  /**\n   * Unsubscribes to a given subscription.\n   *\n   * @param subscription\n   */\n  async unsubscribe(subscription: number) {\n    return this.sendJSONtoChannel({\n      id: this.getEventId(),\n      action: 'unsubscribe',\n      subscription,\n    }).then(() => {\n      this.outstandingSubscriptions.delete(subscription);\n    });\n  }\n\n  /**\n   * Deletes the connection to a channel.\n   */\n  delete() {\n    if (isBrowser) {\n      navigator.sendBeacon(\n        this.channelUrl,\n        JSON.stringify([\n          {\n            action: 'delete',\n          },\n        ])\n      );\n    } else {\n      // TODO\n      // this.sendMessage('delete');\n    }\n  }\n\n  /**\n   * Scry into an gall agent at a path\n   *\n   * @typeParam T - Type of the scry result\n   *\n   * @remarks\n   *\n   * Equivalent to\n   * ```hoon\n   * .^(T %gx /(scot %p our)/[app]/(scot %da now)/[path]/json)\n   * ```\n   * The returned cage must have a conversion to JSON for the scry to succeed\n   *\n   * @param params The scry request\n   * @returns The scry result\n   */\n  async scry<T = any>(params: Scry): Promise<T> {\n    const { app, path } = params;\n    const response = await fetch(\n      `${this.url}/~/scry/${app}${path}.json`,\n      this.fetchOptions\n    );\n    return await response.json();\n  }\n\n  /**\n   * Run a thread\n   *\n   *\n   * @param inputMark   The mark of the data being sent\n   * @param outputMark  The mark of the data being returned\n   * @param threadName  The thread to run\n   * @param body        The data to send to the thread\n   * @returns  The return value of the thread\n   */\n  async thread<R, T = any>(params: Thread<T>): Promise<R> {\n    const {\n      inputMark,\n      outputMark,\n      threadName,\n      body,\n      desk = this.desk,\n    } = params;\n    if (!desk) {\n      throw new Error('Must supply desk to run thread from');\n    }\n    const res = await fetch(\n      `${this.url}/spider/${desk}/${inputMark}/${threadName}/${outputMark}.json`,\n      {\n        ...this.fetchOptions,\n        method: 'POST',\n        body: JSON.stringify(body),\n      }\n    );\n\n    return res.json();\n  }\n\n  /**\n   * Utility function to connect to a ship that has its *.arvo.network domain configured.\n   *\n   * @param name Name of the ship e.g. zod\n   * @param code Code to log in\n   */\n  static async onArvoNetwork(ship: string, code: string): Promise<Urbit> {\n    const url = `https://${ship}.arvo.network`;\n    return await Urbit.authenticate({ ship, url, code });\n  }\n}\n\nexport default Urbit;\n"],"names":["ResumableError","Error","FatalError","Object","defineProperty","lib","value","_typeof","Symbol","iterator","obj","constructor","prototype","isBrowser","window","document","isWebWorker","self","name","isNode","process","versions","node","getLines","onLine","buffer","position","fieldLength","discardTrailingNewline","arr","undefined","a","b","res","Uint8Array","length","set","concat","bufLength","lineStart","lineEnd","subarray","navigator","userAgent","includes","__rest","s","e","t","p","hasOwnProperty","call","indexOf","getOwnPropertySymbols","i","propertyIsEnumerable","EventStreamContentType","LastEventId","fetchEventSource","input","_a","signal","inputSignal","headers","inputHeaders","onopen","inputOnOpen","onmessage","onclose","onerror","openWhenHidden","fetch","inputFetch","rest","Promise","resolve","reject","assign","curRequestController","onVisibilityChange","abort","hidden","create","accept","addEventListener","retryInterval","retryTimer","dispose","removeEventListener","clearTimeout","defaultOnOpen","async","AbortController","response","stream","onChunk","reader","getReader","result","read","done","getBytes","body","onId","onRetry","onMessage","message","data","event","id","retry","decoder","TextDecoder","line","field","decode","valueOffset","parseInt","isNaN","getMessages","err","aborted","interval","setTimeout","innerErr","contentType","get","startsWith","hexString","len","min","Math","pow","max","r","floor","random","toString","Urbit","url","code","desk","this","Date","now","Map","delete","channelUrl","uid","fetchOptions","Cookie","cookie","credentials","authenticate","ship","verbose","airlock","connect","poke","app","mark","json","eventSource","console","log","method","then","RegExp","exec","sseClientInitialized","lastEventId","ok","errorCount","onOpen","lastAcknowledgedEventId","ack","JSON","parse","outstandingPokes","has","funcs","onSuccess","error","onError","outstandingSubscriptions","quit","keys","warn","reset","getEventId","Number","eventId","action","sendJSONtoChannel","stringify","subscribeOnce","path","timeout","request","unsubscribe","subscribe","params","send","all","subscription","sendBeacon","scry","thread","inputMark","outputMark","threadName","onArvoNetwork"],"mappings":"0PAmMaA,UAAuBC,aAEvBC,UAAmBD,gBCnMhCE,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAGT,IAAIC,EAA4B,mBAAXC,QAAoD,iBAApBA,OAAOC,SAAwB,SAAUC,GAAO,cAAcA,GAAS,SAAUA,GAAO,OAAOA,GAAyB,mBAAXF,QAAyBE,EAAIC,cAAgBH,QAAUE,IAAQF,OAAOI,UAAY,gBAAkBF,GAIlQG,EAA8B,oBAAXC,aAAqD,IAApBA,OAAOC,SAG3DC,EAA8E,YAA/C,oBAATC,KAAuB,YAAcV,EAAQU,QAAuBA,KAAKN,aAAyC,+BAA1BM,KAAKN,YAAYO,KAG/HC,EAA4B,oBAAZC,SAA+C,MAApBA,QAAQC,UAA6C,MAAzBD,QAAQC,SAASC,mBAWxET,ECpBb,SAASU,EAASC,GACrB,IAAIC,EACAC,EACAC,EACAC,GAAyB,EAC7B,OAAO,SAAiBC,QACLC,IAAXL,GACAA,EAASI,EACTH,EAAW,EACXC,GAAe,GAGfF,EA4EZ,SAAgBM,EAAGC,GACf,MAAMC,EAAM,IAAIC,WAAWH,EAAEI,OAASH,EAAEG,QAGxC,OAFAF,EAAIG,IAAIL,GACRE,EAAIG,IAAIJ,EAAGD,EAAEI,QACNF,EAhFUI,CAAOZ,EAAQI,GAE5B,MAAMS,EAAYb,EAAOU,OACzB,IAAII,EAAY,EAChB,KAAOb,EAAWY,GAAW,CACrBV,IACyB,KAArBH,EAAOC,KACPa,IAAcb,GAElBE,GAAyB,GAE7B,IAAIY,GAAW,EACf,KAAOd,EAAWY,IAA0B,IAAbE,IAAkBd,EAC7C,OAAQD,EAAOC,IACX,KAAK,IACoB,IAAjBC,IACAA,EAAcD,EAAWa,GAE7B,MACJ,KAAK,GACDX,GAAyB,EAC7B,KAAK,GACDY,EAAUd,EAItB,IAAiB,IAAbc,EACA,MAEJhB,EAAOC,EAAOgB,SAASF,EAAWC,GAAUb,GAC5CY,EAAYb,EACZC,GAAe,EAEfY,IAAcD,EACdb,OAASK,EAEU,IAAdS,IACLd,EAASA,EAAOgB,SAASF,GACzBb,GAAYa,kBD7BFvB,WACLG,YANH,WACZ,MAAyB,oBAAXL,QAA0C,WAAhBA,OAAOI,MAAqBwB,UAAUC,UAAUC,SAAS,YAAcF,UAAUC,UAAUC,SAAS,UExB9I,IAAIC,EAAkC,SAAUC,EAAGC,GAC/C,IAAIC,EAAI,GACR,IAAK,IAAIC,KAAKH,EAAO3C,OAAOS,UAAUsC,eAAeC,KAAKL,EAAGG,IAAMF,EAAEK,QAAQH,GAAK,IAC9ED,EAAEC,GAAKH,EAAEG,IACb,GAAS,MAALH,GAAqD,mBAAjC3C,OAAOkD,sBACtB,CAAA,IAAIC,EAAI,EAAb,IAAgBL,EAAI9C,OAAOkD,sBAAsBP,GAAIQ,EAAIL,EAAEd,OAAQmB,IAC3DP,EAAEK,QAAQH,EAAEK,IAAM,GAAKnD,OAAOS,UAAU2C,qBAAqBJ,KAAKL,EAAGG,EAAEK,MACvEN,EAAEC,EAAEK,IAAMR,EAAEG,EAAEK,KAE1B,OAAON,GAGJ,MAAMQ,EAAyB,oBAEhCC,EAAc,gBACb,SAASC,EAAiBC,EAAOC,GACpC,IAAMC,OAAQC,EAAaC,QAASC,EAAcC,OAAQC,EAAWC,UAAEA,EAASC,QAAEA,EAAOC,QAAEA,EAAOC,eAAEA,EAAgBC,MAAOC,GAAeZ,EAAIa,EAAO5B,EAAOe,EAAI,CAAC,SAAU,UAAW,SAAU,YAAa,UAAW,UAAW,iBAAkB,UACrP,OAAO,IAAIc,SAAQ,CAACC,EAASC,KACzB,MAAMb,EAAU5D,OAAO0E,OAAO,GAAIb,GAIlC,IAAIc,EACJ,SAASC,IACLD,EAAqBE,QAChBjE,SAASkE,QACVC,IAPHnB,EAAQoB,SACTpB,EAAQoB,OAAS3B,GAShBc,GACDvD,SAASqE,iBAAiB,mBAAoBL,GAElD,IAAIM,EAnBiB,IAoBjBC,EAAa,EACjB,SAASC,IACLxE,SAASyE,oBAAoB,mBAAoBT,GACjDjE,OAAO2E,aAAaH,GACpBR,EAAqBE,QAEzBlB,MAAAA,GAA0DA,EAAYsB,iBAAiB,SAAS,KAC5FG,IACAZ,OAEJ,MAAMJ,EAAQC,MAAAA,EAA+CA,EAAa1D,OAAOyD,MAC3EN,EAASC,MAAAA,EAAiDA,EAAcwB,EAC9EC,eAAeT,IACX,IAAItB,EACJkB,EAAuB,IAAIc,gBAC3B,IACI,MAAMC,QAAiBtB,EAAMZ,EAAOxD,OAAO0E,OAAO1E,OAAO0E,OAAO,GAAIJ,GAAO,CAAEV,QAAAA,EAASF,OAAQiB,EAAqBjB,gBAC7GI,EAAO4B,SDlDtBF,eAAwBG,EAAQC,GACnC,MAAMC,EAASF,EAAOG,YACtB,IAAIC,EACJ,OAASA,QAAeF,EAAOG,QAAQC,MACnCL,EAAQG,EAAO5F,OC+CD+F,CAASR,EAASS,KAAM/E,EDUvC,SAAqBgF,EAAMC,EAASC,GACvC,IAAIC,EAwCG,CACHC,KAAM,GACNC,MAAO,GACPC,GAAI,GACJC,WAAOhF,GA3CX,MAAMiF,EAAU,IAAIC,YACpB,OAAO,SAAgBC,EAAMtF,GACzB,GAAoB,IAAhBsF,EAAK9E,OACLsE,MAAAA,GAAsDA,EAAUC,GAChEA,EAmCD,CACHC,KAAM,GACNC,MAAO,GACPC,GAAI,GACJC,WAAOhF,QArCF,GAAIH,EAAc,EAAG,CACtB,MAAMuF,EAAQH,EAAQI,OAAOF,EAAKxE,SAAS,EAAGd,IACxCyF,EAAczF,GAAyC,KAA1BsF,EAAKtF,EAAc,GAAY,EAAI,GAChErB,EAAQyG,EAAQI,OAAOF,EAAKxE,SAAS2E,IAC3C,OAAQF,GACJ,IAAK,OACDR,EAAQC,KAAOD,EAAQC,KACjBD,EAAQC,KAAO,KAAOrG,EACtBA,EACN,MACJ,IAAK,QACDoG,EAAQE,MAAQtG,EAChB,MACJ,IAAK,KACDiG,EAAKG,EAAQG,GAAKvG,GAClB,MACJ,IAAK,QACD,MAAMwG,EAAQO,SAAS/G,EAAO,IACzBgH,MAAMR,IACPN,EAAQE,EAAQI,MAAQA,MCrCOS,EAAYV,IAC3CA,EACA9C,EAAQN,GAAeoD,SAGhB9C,EAAQN,MAEpBqD,IACCzB,EAAgByB,IACjB3C,KACHC,MAAAA,GAAkDA,IAClDmB,IACAZ,IAEJ,MAAO6C,GACH,IAAK1C,EAAqBjB,OAAO4D,QAC7B,IACI,MAAMC,EAAqF,QAAzE9D,EAAKS,MAAAA,OAAyC,EAASA,EAAQmD,UAAyB,IAAP5D,EAAgBA,EAAKyB,EACxHvE,OAAO2E,aAAaH,GACpBA,EAAaxE,OAAO6G,WAAWzC,EAAQwC,GAE3C,MAAOE,GACHrC,IACAX,EAAOgD,KAKvB1C,OAGR,SAASQ,EAAcG,GACnB,MAAMgC,EAAchC,EAAS9B,QAAQ+D,IAAI,gBACzC,KAAMD,MAAAA,OAAiD,EAASA,EAAYE,WAAWvE,IACnF,MAAM,IAAIvD,MAAM,0DAAkE4H,cC3D1EG,EAAUC,GACxB,MACMC,EAAMC,KAAKC,IAAI,GAAID,KAAKD,IAAID,EADnB,GACkC,GAC3CI,EAAMF,KAAKC,IAAI,GAAID,KAAKD,IAAID,EAFnB,IAEmC,EAElD,IAAIK,GADMH,KAAKI,MAAMJ,KAAKK,UAAYH,EAAMH,EAAM,IAAMA,GAC9CO,SAAS,IACnB,KAAOH,EAAEnG,OAAS8F,GAChBK,GAAQN,EAAUC,EANL,GAQf,OAAOK,QCbII,EAoGX/H,YAAmBgI,EAAoBC,EAAsBC,GAI3D,OAJiBC,SAAAH,EAAoBG,UAAAF,EAAsBE,UAAAD,EAhGrDC,SAAc,GAAGX,KAAKI,MAAMQ,KAAKC,MAAQ,QAAShB,EAAU,KAK5Dc,iBAAsB,EAEtBA,6BAAkC,EAKlCA,2BAAgC,EAgBhCA,sBAA8C,IAAIG,IAWlDH,8BACN,IAAIG,IAKEH,WAAQ,IAAIlD,gBAeZkD,gBAAa,EAErBA,aAAiC,KAEjCA,aAAuB,KAEvBA,YAAsB,KA+BhBjI,GACFC,OAAOsE,iBAAiB,eAAgB0D,KAAKI,QAExCJ,KA/BTK,iBACE,MAAO,GAAGL,KAAKH,iBAAiBG,KAAKM,MAGvCC,mBACE,MAAMtF,EAAmB,CACvB,eAAgB,oBAKlB,OAHKlD,IACHkD,EAAQuF,OAASR,KAAKS,QAEjB,CACLC,YAAa,UACbrE,OAAQ,IACRpB,QAAAA,EACAF,OAAQiF,KAAK9D,MAAMnB,QA2BvB4F,2BAA0BC,KACxBA,EAAIf,IACJA,EAAGC,KACHA,EAAIe,QACJA,GAAU,IAEV,MAAMC,EAAU,IAAIlB,EAAM,UAAUC,IAAOC,GAU3C,OATAgB,EAAQD,QAAUA,EAClBC,EAAQF,KAAOA,QACTE,EAAQC,gBACRD,EAAQE,KAAK,CACjBC,IAAK,OACLC,KAAM,UACNC,KAAM,0BAEFL,EAAQM,cACPN,EAOTC,gBASE,OARIf,KAAKa,SACPQ,QAAQC,IACN,YAAYtB,KAAKF,QACjB/H,EAC0C,oCAAGiI,KAAKH,cAC9C,gCAGDpE,MAAM,GAAGuE,KAAKH,cAAe,CAClC0B,OAAQ,OACR/D,KAAM,YAAYwC,KAAKF,OACvBY,YAAa,YACZc,MAAMzE,IACHiD,KAAKa,SACPQ,QAAQC,IAAI,mCAAoCvE,GAElD,MAAM0D,EAAS1D,EAAS9B,QAAQ+D,IAAI,cAC/BgB,KAAKY,OACRZ,KAAKY,KAAO,IAAIa,OAAO,qBAAqBC,KAAKjB,GAAQ,IAEtD1I,IACHiI,KAAKS,OAASA,MAQpBW,oBACE,OAAIpB,KAAK2B,qBACA/F,QAAQC,UAEQ,IAArBmE,KAAK4B,aAUT5B,KAAK2B,sBAAuB,EACrB,IAAI/F,SAAQ,CAACC,EAASC,KAS3BlB,EAAiBoF,KAAKK,WAAY,IAC7BL,KAAKO,aACR/E,gBAAgB,EAChBL,OAAQ0B,MAAOE,IAIb,GAHIiD,KAAKa,SACPQ,QAAQC,IAAI,qBAAsBvE,GAEhCA,EAAS8E,GAIX,OAHA7B,KAAK8B,WAAa,EAClB9B,KAAK+B,QAAU/B,KAAK+B,cACpBlG,IAEK,CACL,MAAM6C,EAAM,IAAIvH,MAAM,8BACtB2E,EAAO4C,KAGXrD,UAAYyC,IAIV,GAHIkC,KAAKa,SACPQ,QAAQC,IAAI,iBAAkBxD,GAE3BA,EAAMC,KACXiC,KAAK4B,YAAcrD,SAAST,EAAMC,GAAI,IAClCiC,KAAK4B,YAAc5B,KAAKgC,wBAA0B,IACpDhC,KAAKiC,IAAIjC,KAAK4B,aAGZ9D,EAAMD,MAAQqE,KAAKC,MAAMrE,EAAMD,OAAO,CACxC,MAAMA,EAAYqE,KAAKC,MAAMrE,EAAMD,MAEnC,GACoB,SAAlBA,EAAKd,UACLiD,KAAKoC,iBAAiBC,IAAIxE,EAAKE,IAC/B,CACA,MAAMuE,EAAQtC,KAAKoC,iBAAiBpD,IAAInB,EAAKE,IACzCF,EAAKzD,eAAe,MACtBkI,EAAMC,YACG1E,EAAKzD,eAAe,QAC7BiH,QAAQmB,MAAM3E,EAAKa,KACnB4D,EAAMG,QAAQ5E,EAAKa,MAEnB2C,QAAQmB,MAAM,wBAAyB3E,GAEzCmC,KAAKoC,iBAAiBhC,OAAOvC,EAAKE,SAC7B,GACa,cAAlBF,EAAKd,UACLiD,KAAK0C,yBAAyBL,IAAIxE,EAAKE,IACvC,CACA,MAAMuE,EAAQtC,KAAK0C,yBAAyB1D,IAAInB,EAAKE,IACjDF,EAAKzD,eAAe,SACtBiH,QAAQmB,MAAM3E,EAAKa,KACnB4D,EAAM5D,IAAIb,EAAKa,IAAKb,EAAKE,IACzBiC,KAAK0C,yBAAyBtC,OAAOvC,EAAKE,UAEvC,GACa,SAAlBF,EAAKd,UACLiD,KAAK0C,yBAAyBL,IAAIxE,EAAKE,IACvC,CACA,MAAMuE,EAAQtC,KAAK0C,yBAAyB1D,IAAInB,EAAKE,IACrD,IACEuE,EAAMxE,MAAMD,EAAKsD,MACjB,MAAOlH,GACPoH,QAAQmB,MAAM,6CAA8CvI,SAEzD,GACa,SAAlB4D,EAAKd,UACLiD,KAAK0C,yBAAyBL,IAAIxE,EAAKE,IACvC,CACciC,KAAK0C,yBAAyB1D,IAAInB,EAAKE,IAC/C4E,KAAK9E,GACXmC,KAAK0C,yBAAyBtC,OAAOvC,EAAKE,SAE1CsD,QAAQC,IAAI,IAAItB,KAAK0C,yBAAyBE,SAC9CvB,QAAQC,IAAI,wBAAyBzD,KAI3CtC,QAAUiH,IAER,GADAnB,QAAQwB,KAAKL,GACTxC,KAAK8B,aAAe,EAEtB,OADA9B,KAAKtC,SAAWsC,KAAKtC,UACqB,IAAnC2B,KAAKC,IAAI,EAAGU,KAAK8B,WAAa,GAGvC,MADA9B,KAAKyC,SAAWzC,KAAKyC,QAAQD,GACvBA,GAERlH,QAAS,KAEP,MADA+F,QAAQC,IAAI,KACN,IAAInK,MAAM,6DAzGd6I,KAAKgB,KAAK,CACdC,IAAK,OACLC,KAAM,UACNC,KAAM,wBAgHZ2B,QACE9C,KAAKI,SACLJ,KAAK9D,MAAMA,QACX8D,KAAK9D,MAAQ,IAAIY,gBACjBkD,KAAKM,IAAM,GAAGjB,KAAKI,MAAMQ,KAAKC,MAAQ,QAAShB,EAAU,KACzDc,KAAK4B,YAAc,EACnB5B,KAAKgC,wBAA0B,EAC/BhC,KAAK0C,yBAA2B,IAAIvC,IACpCH,KAAKoC,iBAAmB,IAAIjC,IAC5BH,KAAK2B,sBAAuB,EAMtBoB,aAEN,OADA/C,KAAK4B,YAAcoB,OAAOhD,KAAK4B,aAAe,EACvC5B,KAAK4B,YAQNK,UAAUgB,GAChBjD,KAAKgC,wBAA0BiB,EAC/B,MAAMrF,EAAmB,CACvBsF,OAAQ,MACR,WAAYD,GAGd,aADMjD,KAAKmD,kBAAkBvF,GACtBqF,EAGDE,2BAA2BhC,GAMjC,WALuB1F,MAAMuE,KAAKK,WAAY,IACzCL,KAAKO,aACRgB,OAAQ,MACR/D,KAAM0E,KAAKkB,UAAUjC,MAETU,GACZ,MAAM,IAAI1K,MAAM,yBAEb6I,KAAK2B,4BACF3B,KAAKoB,cAafiC,oBAA6BpC,EAAaqC,EAAcC,GACtD,OAAO,IAAI3H,SAAWiB,MAAOhB,EAASC,KACpC,IAAIwB,GAAO,EACPS,EAAoB,KACxB,MAWMyF,EAAU,CAAEvC,IAAAA,EAAKqC,KAAAA,EAAMxF,MANd7D,IACRqD,IACHzB,EAAQ5B,GACR+F,KAAKyD,YAAY1F,KAGeW,IAAK5C,EAAQ6G,KAXpC,KACNrF,GACHxB,EAAO,UAWXiC,QAAWiC,KAAK0D,UAAUF,GAEtBD,GACF1E,YAAW,KACJvB,IACHA,GAAO,EACPxB,EAAO,WACPkE,KAAKyD,YAAY1F,MAElBwF,MAYTvC,WAAc2C,GACZ,MAAM1C,IAAEA,EAAGC,KAAEA,EAAIC,KAAEA,EAAIP,KAAEA,EAAI2B,UAAEA,EAASE,QAAEA,GAAY,CACpDF,UAAW,OACXE,QAAS,OACT7B,KAAMZ,KAAKY,QACR+C,GAEC/F,EAAmB,CACvBG,GAAIiC,KAAK+C,aACTG,OAAQ,OACRtC,KAAAA,EACAK,IAAAA,EACAC,KAAAA,EACAC,KAAAA,IAEKyC,EAAMxG,SAAgBxB,QAAQiI,IAAI,CACvC7D,KAAKmD,kBAAkBvF,GACvB,IAAIhC,SAAgB,CAACC,EAASC,KAC5BkE,KAAKoC,iBAAiB9I,IAAIsE,EAAQG,GAAI,CACpCwE,UAAW,KACTA,IACA1G,EAAQ+B,EAAQG,KAElB0E,QAAU3E,IACR2E,EAAQ3E,GACRhC,EAAOgC,EAAMY,aAKrB,OAAOtB,EAWTsG,gBAAgBC,GACd,MAAM1C,IAAEA,EAAGqC,KAAEA,EAAI1C,KAAEA,EAAIlC,IAAEA,EAAGZ,MAAEA,EAAK6E,KAAEA,GAAS,CAC5CjE,IAAK,OACLZ,MAAO,OACP6E,KAAM,OACN/B,KAAMZ,KAAKY,QACR+C,GAGC/F,EAAmB,CACvBG,GAAIiC,KAAK+C,aACTG,OAAQ,YACRtC,KAAAA,EACAK,IAAAA,EACAqC,KAAAA,GAaF,OAVAtD,KAAK0C,yBAAyBpJ,IAAIsE,EAAQG,GAAI,CAC5CkD,IAAAA,EACAqC,KAAAA,EACA5E,IAAAA,EACAZ,MAAAA,EACA6E,KAAAA,UAGI3C,KAAKmD,kBAAkBvF,GAEtBA,EAAQG,GAQjB0F,kBAAkBK,GAChB,OAAO9D,KAAKmD,kBAAkB,CAC5BpF,GAAIiC,KAAK+C,aACTG,OAAQ,cACRY,aAAAA,IACCtC,MAAK,KACNxB,KAAK0C,yBAAyBtC,OAAO0D,MAOzC1D,SACMrI,GACF6B,UAAUmK,WACR/D,KAAKK,WACL6B,KAAKkB,UAAU,CACb,CACEF,OAAQ,aA0BlBc,WAAoBL,GAClB,MAAM1C,IAAEA,EAAGqC,KAAEA,GAASK,EAChB5G,QAAiBtB,MACrB,GAAGuE,KAAKH,cAAcoB,IAAMqC,SAC5BtD,KAAKO,cAEP,aAAaxD,EAASoE,OAaxB8C,aAAyBN,GACvB,MAAMO,UACJA,EAASC,WACTA,EAAUC,WACVA,EAAU5G,KACVA,EAAIuC,KACJA,EAAOC,KAAKD,MACV4D,EACJ,IAAK5D,EACH,MAAM,IAAI5I,MAAM,uCAWlB,aATkBsE,MAChB,GAAGuE,KAAKH,cAAcE,KAAQmE,KAAaE,KAAcD,SACzD,IACKnE,KAAKO,aACRgB,OAAQ,OACR/D,KAAM0E,KAAKkB,UAAU5F,MAId2D,OASbkD,2BAA2BzD,EAAcd,GACvC,MAAMD,EAAM,WAAWe,iBACvB,aAAahB,EAAMe,aAAa,CAAEC,KAAAA,EAAMf,IAAAA,EAAKC,KAAAA"}